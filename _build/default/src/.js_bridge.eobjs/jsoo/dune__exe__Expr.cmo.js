// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cmo, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Dune__exe__Expr
//# unitInfo: Requires: Stdlib, Stdlib__Float, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "\xce\xb8",
    cst$5 = "\xcf\x86",
    cst$2 = " + ",
    cst$3 = " - ",
    cst_4g = "%.4g",
    cst_s_s$0 = "%s + %s",
    cst_s_s$1 = "%s - %s",
    cst_s_s = "%s(%s)",
    cst_s = "-%s",
    cst_phi$1 = "\\phi",
    cst_theta$1 = "\\theta",
    cst_r$1 = "r",
    cst_t$1 = "t",
    caml_equal = runtime.caml_equal,
    caml_round_float = runtime.caml_round_float;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = "\xce\xa6'",
    cst = cst$4,
    cst$0 = cst$5,
    all_coords = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    zero = [0, 0.],
    one = [0, 1.],
    two = [0, 2.],
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    cst_t = cst_t$1,
    cst_r = cst_r$1,
    cst_t$0 = cst_t$1,
    cst_r$0 = cst_r$1,
    cst_theta = cst_theta$1,
    cst_phi = cst_phi$1,
    _a_ = [1, cst_t$1],
    _b_ = [1, cst_r$1],
    _c_ = [1, cst$4],
    _d_ = [1, cst$5],
    cst_b = "b'",
    _e_ = [0, [8, [0, 0, 3], 0, [0, 4], 0], cst_4g],
    _f_ = [0, [2, 0, [12, 40, [2, 0, [12, 41, 0]]]], cst_s_s],
    _g_ = [0, [12, 45, [2, 0, 0]], cst_s],
    _h_ = [0, [2, 0, [11, cst$2, [2, 0, 0]]], cst_s_s$0],
    _i_ = [0, [2, 0, [11, cst$3, [2, 0, 0]]], cst_s_s$1],
    _j_ = [0, [2, 0, [11, "\xc2\xb7", [2, 0, 0]]], "%s\xc2\xb7%s"],
    _k_ = [0, [2, 0, [12, 47, [2, 0, 0]]], "%s/%s"],
    _l_ = [0, [2, 0, [12, 94, [2, 0, 0]]], "%s^%s"],
    _m_ = [0, [11, "exp(", [2, 0, [12, 41, 0]]], "exp(%s)"],
    _n_ = [0, [11, "ln(", [2, 0, [12, 41, 0]]], "ln(%s)"],
    _o_ = [0, [11, "sin(", [2, 0, [12, 41, 0]]], "sin(%s)"],
    _p_ = [0, [11, "cos(", [2, 0, [12, 41, 0]]], "cos(%s)"],
    _q_ = [0, [11, "\xe2\x88\x9a(", [2, 0, [12, 41, 0]]], "\xe2\x88\x9a(%s)"],
    _r_ =
      [0, [11, "\xce\xb4_", [2, 0, [12, 94, [2, 0, 0]]]], "\xce\xb4_%s^%s"],
    _s_ =
      [0,
       [11, "\xe2\x88\x82_", [2, 0, [12, 40, [2, 0, [12, 41, 0]]]]],
       "\xe2\x88\x82_%s(%s)"],
    _t_ = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"],
    _u_ = [0, [8, [0, 0, 3], 0, [0, 4], 0], cst_4g],
    cst_phi$0 = cst_phi$1,
    cst_theta$0 = cst_theta$1,
    _v_ = [0, [2, 0, [12, 40, [2, 0, [12, 41, 0]]]], cst_s_s],
    _w_ = [0, [12, 45, [2, 0, 0]], cst_s],
    _x_ = [0, [2, 0, [11, cst$2, [2, 0, 0]]], cst_s_s$0],
    _y_ = [0, [2, 0, [11, cst$3, [2, 0, 0]]], cst_s_s$1],
    _z_ = [0, [2, 0, [11, " \\cdot ", [2, 0, 0]]], "%s \\cdot %s"],
    _A_ =
      [0,
       [11, "\\frac{", [2, 0, [11, "}{", [2, 0, [12, 125, 0]]]]],
       "\\frac{%s}{%s}"],
    _B_ = [0, [2, 0, [11, "^{", [2, 0, [12, 125, 0]]]], "%s^{%s}"],
    _C_ = [0, [11, "e^{", [2, 0, [12, 125, 0]]], "e^{%s}"],
    _D_ = [0, [11, "\\ln(", [2, 0, [12, 41, 0]]], "\\ln(%s)"],
    _E_ = [0, [11, "\\sin(", [2, 0, [12, 41, 0]]], "\\sin(%s)"],
    _F_ = [0, [11, "\\cos(", [2, 0, [12, 41, 0]]], "\\cos(%s)"],
    _G_ = [0, [11, "\\sqrt{", [2, 0, [12, 125, 0]]], "\\sqrt{%s}"],
    _H_ =
      [0,
       [11, "\\delta^{", [2, 0, [11, "}_{", [2, 0, [12, 125, 0]]]]],
       "\\delta^{%s}_{%s}"],
    _I_ =
      [0,
       [11, "\\partial_{", [2, 0, [11, "}(", [2, 0, [12, 41, 0]]]]],
       "\\partial_{%s}(%s)"],
    _J_ =
      [0, [11, "\\left(", [2, 0, [11, "\\right)", 0]]], "\\left(%s\\right)"];
   function coord_to_string(param){
    switch(param){
      case 0:
       return cst_t;
      case 1:
       return cst_r;
      case 2:
       return cst;
      default: return cst$0;
    }
   }
   function coord_to_latex(param){
    switch(param){
      case 0:
       return cst_t$0;
      case 1:
       return cst_r$0;
      case 2:
       return cst_theta;
      default: return cst_phi;
    }
   }
   function is_zero(param){
    if(0 === param[0] && param[1] === 0.) return 1;
    return 0;
   }
   function is_one(param){
    if(0 === param[0] && param[1] === 1.) return 1;
    return 0;
   }
   function neg(e){
    switch(e[0]){
      case 0:
       var n = e[1]; return [0, - n];
      case 3:
       var e$0 = e[1]; return e$0;
      default: return [3, e];
    }
   }
   function add(e1, e2){
    a:
    {
     if(0 === e1[0] && e1[1] === 0.){var e = e2; break a;}
     switch(e2[0]){
       case 0:
        if(e2[1] === 0.){var e = e1; break a;} break;
       case 3:
        var e2$0 = e2[1]; if(caml_equal(e1, e2$0)) return zero; break;
     }
     switch(e1[0]){
       case 0:
        if(0 === e2[0]){var b = e2[1], a = e1[1]; return [0, a + b];} break;
       case 3:
        var e1$0 = e1[1]; if(caml_equal(e1$0, e2)) return zero; break;
     }
     return [4, e1, e2];
    }
    return e;
   }
   function sub(e1, e2){
    if(0 === e2[0] && e2[1] === 0.) return e1;
    if(0 === e1[0]){
     var a = e1[1];
     if(a === 0.) return neg(e2);
     if(0 === e2[0]){var b = e2[1]; return [0, a - b];}
    }
    return caml_equal(e1, e2) ? zero : [5, e1, e2];
   }
   function mul(e1, e2){
    a:
    {
     if(0 === e1[0] && e1[1] === 0.) break a;
     if(0 === e2[0] && e2[1] === 0.) break a;
     b:
     {
      if(0 === e1[0] && e1[1] === 1.){var e$0 = e2; break b;}
      if(0 === e2[0] && e2[1] === 1.){var e$0 = e1; break b;}
      c:
      {
       if(0 === e1[0] && e1[1] === -1.){var e = e2; break c;}
       if(0 === e2[0]){
        if(e2[1] === -1.){var e = e1; break c;}
        if(0 === e1[0]){var b = e2[1], a = e1[1]; return [0, a * b];}
       }
       return [6, e1, e2];
      }
      return neg(e);
     }
     return e$0;
    }
    return zero;
   }
   function div(e1, e2){
    if(0 === e1[0] && e1[1] === 0.) return zero;
    if(0 === e2[0]){
     if(e2[1] === 1.) return e1;
     if(0 === e1[0]){
      var b = e2[1], a = e1[1];
      if(b !== 0.) return [0, a / b];
     }
    }
    return caml_equal(e1, e2) ? one : [7, e1, e2];
   }
   function pow(e1, e2){
    if(0 === e2[0]){
     var _aQ_ = e2[1];
     if(_aQ_ === 0.) return one;
     if(_aQ_ === 1.) return e1;
    }
    if(0 === e1[0]){
     var a = e1[1];
     if(a === 1.) return one;
     if(0 === e2[0]){var b = e2[1]; return [0, Math.pow(a, b)];}
    }
    return [8, e1, e2];
   }
   function sqrt_expr(e){
    switch(e[0]){
      case 0:
       var n = e[1]; if(0. <= n) return [0, Math.sqrt(n)]; break;
      case 8:
       var _aP_ = e[2];
       if(0 === _aP_[0] && _aP_[1] === 2.){var e$0 = e[1]; return e$0;}
       break;
    }
    return [13, e];
   }
   function exp_expr(e){
    switch(e[0]){
      case 0:
       if(e[1] === 0.) return one; break;
      case 10:
       var e$0 = e[1]; return e$0;
    }
    return [9, e];
   }
   function log_expr(e){
    switch(e[0]){
      case 0:
       if(e[1] === 1.) return zero; break;
      case 9:
       var e$0 = e[1]; return e$0;
    }
    return [10, e];
   }
   function sin_expr(e){
    if(0 === e[0] && e[1] === 0.) return zero;
    return [11, e];
   }
   function cos_expr(e){
    if(0 === e[0] && e[1] === 0.) return one;
    return [12, e];
   }
   function coord_var(param){
    switch(param){
      case 0:
       return _a_;
      case 1:
       return _b_;
      case 2:
       return _c_;
      default: return _d_;
    }
   }
   function depends_on(coord, expr){
    var v = coord_var(coord);
    function check(param){
     var param$0 = param;
     for(;;)
      switch(param$0[0]){
        case 0:
         return 0;
        case 1:
         var s = param$0[1]; return caml_equal([1, s], v);
        case 2:
         var e = param$0[2]; param$0 = e; break;
        case 14:
         return 0;
        case 15:
         var e$1 = param$0[1]; param$0 = e$1; break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
         var b = param$0[2], a = param$0[1], _aO_ = check(a);
         if(_aO_) return _aO_;
         param$0 = b;
         break;
        default: var e$0 = param$0[1]; param$0 = e$0;
      }
    }
    return check(expr);
   }
   function differentiate(coord, expr){
    var v = coord_var(coord);
    switch(expr[0]){
      case 0:
       return zero;
      case 1:
       var s = expr[1]; return caml_equal([1, s], v) ? one : zero;
      case 2:
       var arg = expr[2], name = expr[1];
       return name !== "b"
               ? name
                 !== "\xce\xa6"
                 ? [15, expr, coord]
                 : 1
                   === coord
                   ? mul([2, cst$1, arg], differentiate(coord, arg))
                   : zero
               : 1
                 === coord
                 ? mul([2, cst_b, arg], differentiate(coord, arg))
                 : zero;
      case 3:
       var e = expr[1]; return neg(differentiate(coord, e));
      case 4:
       var b = expr[2], a = expr[1], _aN_ = differentiate(coord, b);
       return add(differentiate(coord, a), _aN_);
      case 5:
       var b$0 = expr[2], a$0 = expr[1], _aM_ = differentiate(coord, b$0);
       return sub(differentiate(coord, a$0), _aM_);
      case 6:
       var
        b$1 = expr[2],
        a$1 = expr[1],
        _aF_ = mul(a$1, differentiate(coord, b$1));
       return add(mul(differentiate(coord, a$1), b$1), _aF_);
      case 7:
       var
        b$2 = expr[2],
        a$2 = expr[1],
        _aG_ = pow(b$2, two),
        _aH_ = mul(a$2, differentiate(coord, b$2));
       return div(sub(mul(differentiate(coord, a$2), b$2), _aH_), _aG_);
      case 8:
       var base = expr[1], match = expr[2];
       if(0 === match[0]){
        var n = match[1], _aL_ = differentiate(coord, base);
        return mul(mul([0, n], pow(base, [0, n - 1.])), _aL_);
       }
       var
        exp = expr[2],
        _aI_ = log_expr(base),
        term1 = mul(differentiate(coord, exp), _aI_),
        term2 = mul(exp, div(differentiate(coord, base), base)),
        _aJ_ = add(term1, term2);
       return mul(pow(base, exp), _aJ_);
      case 9:
       var e$0 = expr[1]; return mul([9, e$0], differentiate(coord, e$0));
      case 10:
       var e$1 = expr[1]; return div(differentiate(coord, e$1), e$1);
      case 11:
       var e$2 = expr[1]; return mul([12, e$2], differentiate(coord, e$2));
      case 12:
       var e$3 = expr[1];
       return neg(mul([11, e$3], differentiate(coord, e$3)));
      case 13:
       var e$4 = expr[1], _aK_ = mul(two, [13, e$4]);
       return div(differentiate(coord, e$4), _aK_);
      case 14:
       return zero;
      default: return [15, expr, coord];
    }
   }
   function simplify(expr){
    var expr$0 = expr;
    for(;;)
     switch(expr$0[0]){
       case 2:
        var e = expr$0[2], name = expr$0[1]; return [2, name, simplify(e)];
       case 3:
        var e$0 = expr$0[1]; return neg(simplify(e$0));
       case 4:
        var b = expr$0[2], a = expr$0[1], _aA_ = simplify(b);
        return add(simplify(a), _aA_);
       case 5:
        var b$0 = expr$0[2], a$0 = expr$0[1], _aB_ = simplify(b$0);
        return sub(simplify(a$0), _aB_);
       case 6:
        var b$1 = expr$0[2], a$1 = expr$0[1], _aC_ = simplify(b$1);
        return mul(simplify(a$1), _aC_);
       case 7:
        var b$2 = expr$0[2], a$2 = expr$0[1], _aD_ = simplify(b$2);
        return div(simplify(a$2), _aD_);
       case 8:
        var b$3 = expr$0[2], a$3 = expr$0[1], _aE_ = simplify(b$3);
        return pow(simplify(a$3), _aE_);
       case 9:
        var e$1 = expr$0[1]; return exp_expr(simplify(e$1));
       case 10:
        var e$2 = expr$0[1]; return log_expr(simplify(e$2));
       case 11:
        var e$3 = expr$0[1]; return sin_expr(simplify(e$3));
       case 12:
        var e$4 = expr$0[1]; return cos_expr(simplify(e$4));
       case 13:
        var e$5 = expr$0[1]; return sqrt_expr(simplify(e$5));
       case 15:
        var c = expr$0[2], e$6 = expr$0[1], se = simplify(e$6);
        if(! depends_on(c, se)) return zero;
        var expr$1 = differentiate(c, se);
        expr$0 = expr$1;
        break;
       default: return expr$0;
     }
   }
   function full_simplify(expr){
    var expr$0 = expr;
    for(;;){
     var expr$1 = simplify(expr$0);
     if(caml_equal(expr$1, expr$0)) return expr$1;
     expr$0 = expr$1;
    }
   }
   function to_string(expr){
    switch(expr[0]){
      case 0:
       var n = expr[1];
       return n === caml_round_float(n)
               ? caml_call1(Stdlib[33], n | 0)
               : caml_call2(Stdlib_Printf[4], _e_, n);
      case 1:
       var s = expr[1]; return s;
      case 2:
       var arg = expr[2], name = expr[1], _af_ = to_string(arg);
       return caml_call3(Stdlib_Printf[4], _f_, name, _af_);
      case 3:
       var e = expr[1], _ag_ = to_string_parens(e);
       return caml_call2(Stdlib_Printf[4], _g_, _ag_);
      case 4:
       var b = expr[2], a = expr[1], _ah_ = to_string(b), _ai_ = to_string(a);
       return caml_call3(Stdlib_Printf[4], _h_, _ai_, _ah_);
      case 5:
       var
        b$0 = expr[2],
        a$0 = expr[1],
        _aj_ = to_string_parens(b$0),
        _ak_ = to_string(a$0);
       return caml_call3(Stdlib_Printf[4], _i_, _ak_, _aj_);
      case 6:
       var
        b$1 = expr[2],
        a$1 = expr[1],
        _al_ = to_string_parens(b$1),
        _am_ = to_string_parens(a$1);
       return caml_call3(Stdlib_Printf[4], _j_, _am_, _al_);
      case 7:
       var
        b$2 = expr[2],
        a$2 = expr[1],
        _an_ = to_string_parens(b$2),
        _ao_ = to_string_parens(a$2);
       return caml_call3(Stdlib_Printf[4], _k_, _ao_, _an_);
      case 8:
       var
        b$3 = expr[2],
        a$3 = expr[1],
        _ap_ = to_string_parens(b$3),
        _aq_ = to_string_parens(a$3);
       return caml_call3(Stdlib_Printf[4], _l_, _aq_, _ap_);
      case 9:
       var e$0 = expr[1], _ar_ = to_string(e$0);
       return caml_call2(Stdlib_Printf[4], _m_, _ar_);
      case 10:
       var e$1 = expr[1], _as_ = to_string(e$1);
       return caml_call2(Stdlib_Printf[4], _n_, _as_);
      case 11:
       var e$2 = expr[1], _at_ = to_string(e$2);
       return caml_call2(Stdlib_Printf[4], _o_, _at_);
      case 12:
       var e$3 = expr[1], _au_ = to_string(e$3);
       return caml_call2(Stdlib_Printf[4], _p_, _au_);
      case 13:
       var e$4 = expr[1], _av_ = to_string(e$4);
       return caml_call2(Stdlib_Printf[4], _q_, _av_);
      case 14:
       var
        b$4 = expr[2],
        a$4 = expr[1],
        _aw_ = coord_to_string(b$4),
        _ax_ = coord_to_string(a$4);
       return caml_call3(Stdlib_Printf[4], _r_, _ax_, _aw_);
      default:
       var
        c = expr[2],
        e$5 = expr[1],
        _ay_ = to_string(e$5),
        _az_ = coord_to_string(c);
       return caml_call3(Stdlib_Printf[4], _s_, _az_, _ay_);
    }
   }
   function to_string_parens(expr){
    switch(expr[0]){
      case 4:
      case 5:
       var _ae_ = to_string(expr);
       return caml_call2(Stdlib_Printf[4], _t_, _ae_);
      default: return to_string(expr);
    }
   }
   function to_latex(expr){
    switch(expr[0]){
      case 0:
       var n = expr[1];
       return n === caml_round_float(n)
               ? caml_call1(Stdlib[33], n | 0)
               : caml_call2(Stdlib_Printf[4], _u_, n);
      case 1:
       var s = expr[1];
       return s !== cst$4 ? s !== cst$5 ? s : cst_phi$0 : cst_theta$0;
      case 2:
       var arg = expr[2], name = expr[1], _L_ = to_latex(arg);
       return caml_call3(Stdlib_Printf[4], _v_, name, _L_);
      case 3:
       var e = expr[1], _M_ = to_latex_parens(e);
       return caml_call2(Stdlib_Printf[4], _w_, _M_);
      case 4:
       var b = expr[2], a = expr[1], _N_ = to_latex(b), _O_ = to_latex(a);
       return caml_call3(Stdlib_Printf[4], _x_, _O_, _N_);
      case 5:
       var
        b$0 = expr[2],
        a$0 = expr[1],
        _P_ = to_latex_parens(b$0),
        _Q_ = to_latex(a$0);
       return caml_call3(Stdlib_Printf[4], _y_, _Q_, _P_);
      case 6:
       var
        b$1 = expr[2],
        a$1 = expr[1],
        _R_ = to_latex_parens(b$1),
        _S_ = to_latex_parens(a$1);
       return caml_call3(Stdlib_Printf[4], _z_, _S_, _R_);
      case 7:
       var
        b$2 = expr[2],
        a$2 = expr[1],
        _T_ = to_latex(b$2),
        _U_ = to_latex(a$2);
       return caml_call3(Stdlib_Printf[4], _A_, _U_, _T_);
      case 8:
       var
        b$3 = expr[2],
        a$3 = expr[1],
        _V_ = to_latex(b$3),
        _W_ = to_latex_parens(a$3);
       return caml_call3(Stdlib_Printf[4], _B_, _W_, _V_);
      case 9:
       var e$0 = expr[1], _X_ = to_latex(e$0);
       return caml_call2(Stdlib_Printf[4], _C_, _X_);
      case 10:
       var e$1 = expr[1], _Y_ = to_latex(e$1);
       return caml_call2(Stdlib_Printf[4], _D_, _Y_);
      case 11:
       var e$2 = expr[1], _Z_ = to_latex(e$2);
       return caml_call2(Stdlib_Printf[4], _E_, _Z_);
      case 12:
       var e$3 = expr[1], ___ = to_latex(e$3);
       return caml_call2(Stdlib_Printf[4], _F_, ___);
      case 13:
       var e$4 = expr[1], _$_ = to_latex(e$4);
       return caml_call2(Stdlib_Printf[4], _G_, _$_);
      case 14:
       var
        b$4 = expr[2],
        a$4 = expr[1],
        _aa_ = coord_to_latex(b$4),
        _ab_ = coord_to_latex(a$4);
       return caml_call3(Stdlib_Printf[4], _H_, _ab_, _aa_);
      default:
       var
        c = expr[2],
        e$5 = expr[1],
        _ac_ = to_latex(e$5),
        _ad_ = coord_to_latex(c);
       return caml_call3(Stdlib_Printf[4], _I_, _ad_, _ac_);
    }
   }
   function to_latex_parens(expr){
    switch(expr[0]){
      case 4:
      case 5:
       var _K_ = to_latex(expr);
       return caml_call2(Stdlib_Printf[4], _J_, _K_);
      default: return to_latex(expr);
    }
   }
   var
    Dune_exe_Expr =
      [0,
       all_coords,
       coord_to_string,
       coord_to_latex,
       zero,
       one,
       two,
       is_zero,
       is_one,
       neg,
       add,
       sub,
       mul,
       div,
       pow,
       sqrt_expr,
       exp_expr,
       log_expr,
       sin_expr,
       cos_expr,
       coord_var,
       depends_on,
       differentiate,
       simplify,
       full_simplify,
       to_string,
       to_string_parens,
       to_latex,
       to_latex_parens];
   runtime.caml_register_global(83, Dune_exe_Expr, "Dune__exe__Expr");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLmpzX2JyaWRnZS5lb2Jqcy9qc29vL2R1bmVfX2V4ZV9fRXhwci5jbW8uanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLmpzX2JyaWRnZS5lb2Jqcy9qc29vL2R1bmVfX2V4ZV9fRXhwci5jbW8uanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0XzRnIiwiY3N0X3NfcyIsImNzdF9zIiwiY3N0X3BoaSIsImNzdF90aGV0YSIsImNzdF9yIiwiY3N0X3QiLCJjYW1sX2VxdWFsIiwiY2FtbF9yb3VuZF9mbG9hdCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsImFsbF9jb29yZHMiLCJ6ZXJvIiwib25lIiwidHdvIiwiU3RkbGliIiwiU3RkbGliX1ByaW50ZiIsImNzdF9iIiwiY29vcmRfdG9fc3RyaW5nIiwicGFyYW0iLCJjb29yZF90b19sYXRleCIsImlzX3plcm8iLCJpc19vbmUiLCJuZWciLCJlIiwibiIsImFkZCIsImUxIiwiZTIiLCJiIiwiYSIsInN1YiIsIm11bCIsImRpdiIsInBvdyIsInNxcnRfZXhwciIsImV4cF9leHByIiwibG9nX2V4cHIiLCJzaW5fZXhwciIsImNvc19leHByIiwiY29vcmRfdmFyIiwiZGVwZW5kc19vbiIsImNvb3JkIiwiZXhwciIsInYiLCJjaGVjayIsInMiLCJkaWZmZXJlbnRpYXRlIiwiYXJnIiwibmFtZSIsImJhc2UiLCJtYXRjaCIsImV4cCIsInRlcm0xIiwidGVybTIiLCJzaW1wbGlmeSIsImMiLCJzZSIsImZ1bGxfc2ltcGxpZnkiLCJ0b19zdHJpbmciLCJ0b19zdHJpbmdfcGFyZW5zIiwidG9fbGF0ZXgiLCJ0b19sYXRleF9wYXJlbnMiLCJEdW5lX2V4ZV9FeHByIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvd29ya3Nw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c0M7QUFBQTtBQUFBLFdBQUFBLE1BcEJ2RixlQWdCc0M7QUFBQSxPQUFZLDZDQUlxQztBQUFBO0FBQUEsV0FBQUEsTUFwQnZGLGVBaUJzQztBQUFBLE9BQVksNkNBR3FDO0FBQUE7QUFBQSxXQUFBQSxNQXBCdkYsZUFrQndDO0FBQUEsT0FBWSw2Q0FFbUM7QUFBQTtBQUFBO0FBQUEsUUFBQUssTUFwQnZGO0FBQUEsUUFBQUMsTUFBQTtBQUFBLGVBbUJ3RTtBQUFBLGVBQW5CO0FBQUEsT0FBa0Isb0RBQ2dCO0FBQUE7QUFBQTtBQUFBLFFBQUEwQixJQXBCdkY7QUFBQSxRQUFBaEMsTUFBQTtBQUFBLGVBb0IyRTtBQUFBLGVBQW5CO0FBQUEsT0FBa0Isb0RBQWE7QUFBQTtBQUFBO0FBQUEsWUFBQXNDLGdCQUFBbkI7QUFBQUEsSUFHdkY7QUFBQTtBQUFBO0FBQUEsaUJBQ3NEO0FBQUEsT0FBZSw2Q0FDakQ7QUFBQSxlQUFiLHFCQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQW9CO0FBQUFBLE1EbFF0QiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogZXhwci5tbCAtIFN5bWJvbGljIGV4cHJlc3Npb25zIGZvciB0ZW5zb3IgY2FsY3VsdXMgKilcblxuKCogQ29vcmRpbmF0ZXMgKilcbnR5cGUgY29vcmQgPSBUIHwgUiB8IFRoZXRhIHwgUGhpXG5cbmxldCBhbGxfY29vcmRzID0gW1Q7IFI7IFRoZXRhOyBQaGldXG5cbmxldCBjb29yZF90b19zdHJpbmcgPSBmdW5jdGlvblxuICB8IFQgLT4gXCJ0XCIgfCBSIC0+IFwiclwiIHwgVGhldGEgLT4gXCLOuFwiIHwgUGhpIC0+IFwiz4ZcIlxuXG5sZXQgY29vcmRfdG9fbGF0ZXggPSBmdW5jdGlvblxuICB8IFQgLT4gXCJ0XCIgfCBSIC0+IFwiclwiIHwgVGhldGEgLT4gXCJcXFxcdGhldGFcIiB8IFBoaSAtPiBcIlxcXFxwaGlcIlxuXG4oKiBTeW1ib2xpYyBleHByZXNzaW9ucyAqKVxudHlwZSBleHByID1cbiAgfCBOdW0gb2YgZmxvYXQgICAgICAgICAgICAgICAgICAgICAoKiBOdW1lcmljIGNvbnN0YW50ICopXG4gIHwgVmFyIG9mIHN0cmluZyAgICAgICAgICAgICAgICAgICAgKCogTmFtZWQgdmFyaWFibGU6IHIsIM64LCBldGMuICopXG4gIHwgRnVuYyBvZiBzdHJpbmcgKiBleHByICAgICAgICAgICAgKCogRnVuY3Rpb24gYXBwbGljYXRpb246IHNpbijOuCksIM6mKHIpICopXG4gIHwgTmVnIG9mIGV4cHIgICAgICAgICAgICAgICAgICAgICAgKCogLWUgKilcbiAgfCBBZGQgb2YgZXhwciAqIGV4cHIgICAgICAgICAgICAgICAoKiBlMSArIGUyICopXG4gIHwgU3ViIG9mIGV4cHIgKiBleHByICAgICAgICAgICAgICAgKCogZTEgLSBlMiAqKVxuICB8IE11bCBvZiBleHByICogZXhwciAgICAgICAgICAgICAgICgqIGUxICogZTIgKilcbiAgfCBEaXYgb2YgZXhwciAqIGV4cHIgICAgICAgICAgICAgICAoKiBlMSAvIGUyICopXG4gIHwgUG93IG9mIGV4cHIgKiBleHByICAgICAgICAgICAgICAgKCogZTEgXiBlMiAqKVxuICB8IEV4cCBvZiBleHByICAgICAgICAgICAgICAgICAgICAgICgqIGVeeCAqKVxuICB8IExvZyBvZiBleHByICAgICAgICAgICAgICAgICAgICAgICgqIGxuKHgpICopXG4gIHwgU2luIG9mIGV4cHIgICAgICAgICAgICAgICAgICAgICAgKCogc2luKHgpICopXG4gIHwgQ29zIG9mIGV4cHIgICAgICAgICAgICAgICAgICAgICAgKCogY29zKHgpICopXG4gIHwgU3FydCBvZiBleHByICAgICAgICAgICAgICAgICAgICAgKCog4oiaeCAqKVxuICB8IERlbHRhIG9mIGNvb3JkICogY29vcmQgICAgICAgICAgICgqIEtyb25lY2tlciBkZWx0YSDOtF7OvF/OvSAqKVxuICB8IFBhcnRpYWwgb2YgZXhwciAqIGNvb3JkICAgICAgICAgICgqIOKIgmUv4oiCeF7OvCAtIFNZTUJPTElDLCB3aWxsIGJlIGNvbXB1dGVkICopXG5cbigqIFNtYXJ0IGNvbnN0cnVjdG9ycyB0aGF0IHNpbXBsaWZ5IGFzIHRoZXkgYnVpbGQgKilcbmxldCB6ZXJvID0gTnVtIDAuMFxubGV0IG9uZSA9IE51bSAxLjBcbmxldCB0d28gPSBOdW0gMi4wXG5cbmxldCBpc196ZXJvID0gZnVuY3Rpb24gTnVtIDAuMCAtPiB0cnVlIHwgXyAtPiBmYWxzZVxubGV0IGlzX29uZSA9IGZ1bmN0aW9uIE51bSAxLjAgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxubGV0IG5lZyA9IGZ1bmN0aW9uXG4gIHwgTnVtIG4gLT4gTnVtICgtLm4pXG4gIHwgTmVnIGUgLT4gZVxuICB8IGUgLT4gTmVnIGVcblxubGV0IGFkZCBlMSBlMiA9IG1hdGNoIGUxLCBlMiB3aXRoXG4gIHwgTnVtIDAuMCwgZSB8IGUsIE51bSAwLjAgLT4gZVxuICB8IE51bSBhLCBOdW0gYiAtPiBOdW0gKGEgKy4gYilcbiAgfCBlMSwgTmVnIGUyIHdoZW4gZTEgPSBlMiAtPiB6ZXJvXG4gIHwgTmVnIGUxLCBlMiB3aGVuIGUxID0gZTIgLT4gemVyb1xuICB8IF8gLT4gQWRkIChlMSwgZTIpXG5cbmxldCBzdWIgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxuICB8IGUsIE51bSAwLjAgLT4gZVxuICB8IE51bSAwLjAsIGUgLT4gbmVnIGVcbiAgfCBOdW0gYSwgTnVtIGIgLT4gTnVtIChhIC0uIGIpXG4gIHwgZTEsIGUyIHdoZW4gZTEgPSBlMiAtPiB6ZXJvXG4gIHwgXyAtPiBTdWIgKGUxLCBlMilcblxubGV0IG11bCBlMSBlMiA9IG1hdGNoIGUxLCBlMiB3aXRoXG4gIHwgTnVtIDAuMCwgXyB8IF8sIE51bSAwLjAgLT4gemVyb1xuICB8IE51bSAxLjAsIGUgfCBlLCBOdW0gMS4wIC0+IGVcbiAgfCBOdW0gKC0xLjApLCBlIHwgZSwgTnVtICgtMS4wKSAtPiBuZWcgZVxuICB8IE51bSBhLCBOdW0gYiAtPiBOdW0gKGEgKi4gYilcbiAgfCBfIC0+IE11bCAoZTEsIGUyKVxuXG5sZXQgZGl2IGUxIGUyID0gbWF0Y2ggZTEsIGUyIHdpdGhcbiAgfCBOdW0gMC4wLCBfIC0+IHplcm9cbiAgfCBlLCBOdW0gMS4wIC0+IGVcbiAgfCBOdW0gYSwgTnVtIGIgd2hlbiBiIDw+IDAuMCAtPiBOdW0gKGEgLy4gYilcbiAgfCBlMSwgZTIgd2hlbiBlMSA9IGUyIC0+IG9uZVxuICB8IF8gLT4gRGl2IChlMSwgZTIpXG5cbmxldCBwb3cgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxuICB8IF8sIE51bSAwLjAgLT4gb25lXG4gIHwgZSwgTnVtIDEuMCAtPiBlXG4gIHwgTnVtIDEuMCwgXyAtPiBvbmVcbiAgfCBOdW0gYSwgTnVtIGIgLT4gTnVtIChhICoqIGIpXG4gIHwgXyAtPiBQb3cgKGUxLCBlMilcblxubGV0IHNxcnRfZXhwciA9IGZ1bmN0aW9uXG4gIHwgTnVtIG4gd2hlbiBuID49IDAuMCAtPiBOdW0gKHNxcnQgbilcbiAgfCBQb3cgKGUsIE51bSAyLjApIC0+IGUgICgqIOKImihlwrIpID0gZSwgYXNzdW1pbmcgcG9zaXRpdmUgKilcbiAgfCBlIC0+IFNxcnQgZVxuXG5sZXQgZXhwX2V4cHIgPSBmdW5jdGlvblxuICB8IE51bSAwLjAgLT4gb25lXG4gIHwgTG9nIGUgLT4gZVxuICB8IGUgLT4gRXhwIGVcblxubGV0IGxvZ19leHByID0gZnVuY3Rpb25cbiAgfCBOdW0gMS4wIC0+IHplcm9cbiAgfCBFeHAgZSAtPiBlXG4gIHwgZSAtPiBMb2cgZVxuXG5sZXQgc2luX2V4cHIgPSBmdW5jdGlvblxuICB8IE51bSAwLjAgLT4gemVyb1xuICB8IGUgLT4gU2luIGVcblxubGV0IGNvc19leHByID0gZnVuY3Rpb25cbiAgfCBOdW0gMC4wIC0+IG9uZVxuICB8IGUgLT4gQ29zIGVcblxuKCogQ29vcmRpbmF0ZSB0byB2YXJpYWJsZSAqKVxubGV0IGNvb3JkX3ZhciA9IGZ1bmN0aW9uXG4gIHwgVCAtPiBWYXIgXCJ0XCJcbiAgfCBSIC0+IFZhciBcInJcIlxuICB8IFRoZXRhIC0+IFZhciBcIs64XCJcbiAgfCBQaGkgLT4gVmFyIFwiz4ZcIlxuXG4oKiBDaGVjayBpZiBleHByZXNzaW9uIGRlcGVuZHMgb24gYSBjb29yZGluYXRlICopXG5sZXQgZGVwZW5kc19vbiBjb29yZCBleHByID1cbiAgbGV0IHYgPSBjb29yZF92YXIgY29vcmQgaW5cbiAgbGV0IHJlYyBjaGVjayA9IGZ1bmN0aW9uXG4gICAgfCBWYXIgcyAtPiBWYXIgcyA9IHZcbiAgICB8IE51bSBfIC0+IGZhbHNlXG4gICAgfCBGdW5jIChfLCBlKSAtPiBjaGVjayBlXG4gICAgfCBOZWcgZSB8IEV4cCBlIHwgTG9nIGUgfCBTaW4gZSB8IENvcyBlIHwgU3FydCBlIC0+IGNoZWNrIGVcbiAgICB8IEFkZCAoYSwgYikgfCBTdWIgKGEsIGIpIHwgTXVsIChhLCBiKSB8IERpdiAoYSwgYikgfCBQb3cgKGEsIGIpIC0+IFxuICAgICAgICBjaGVjayBhIHx8IGNoZWNrIGJcbiAgICB8IERlbHRhIF8gLT4gZmFsc2VcbiAgICB8IFBhcnRpYWwgKGUsIF8pIC0+IGNoZWNrIGUgICgqIFBhcnRpYWwgaXRzZWxmIG1pZ2h0IGRlcGVuZCAqKVxuICBpbiBjaGVjayBleHByXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgU1lNQk9MSUMgRElGRkVSRU5USUFUSU9OIC0gVGhlIGNvcmUgb2YgYWN0dWFsIGNvbXB1dGF0aW9uXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxubGV0IHJlYyBkaWZmZXJlbnRpYXRlIGNvb3JkIGV4cHIgPVxuICBsZXQgZCA9IGRpZmZlcmVudGlhdGUgY29vcmQgaW5cbiAgbGV0IHYgPSBjb29yZF92YXIgY29vcmQgaW5cbiAgbWF0Y2ggZXhwciB3aXRoXG4gIHwgTnVtIF8gLT4gemVyb1xuICB8IFZhciBzIC0+IGlmIFZhciBzID0gdiB0aGVuIG9uZSBlbHNlIHplcm9cbiAgfCBGdW5jIChuYW1lLCBhcmcpIC0+XG4gICAgICAoKiBDaGFpbiBydWxlOiBkL2R4IGYoZyh4KSkgPSBmJyhnKHgpKSAqIGcnKHgpICopXG4gICAgICAoKiBGb3Igbm93LCBoYW5kbGUgc3BlY2lmaWMgZnVuY3Rpb25zICopXG4gICAgICBiZWdpbiBtYXRjaCBuYW1lIHdpdGhcbiAgICAgIHwgXCLOplwiIC0+ICgqIFJlZHNoaWZ0IGZ1bmN0aW9uIM6mKHIpICopXG4gICAgICAgICAgaWYgY29vcmQgPSBSIHRoZW4gXG4gICAgICAgICAgICBtdWwgKEZ1bmMgKFwizqYnXCIsIGFyZykpIChkIGFyZylcbiAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAgemVyb1xuICAgICAgfCBcImJcIiAtPiAoKiBTaGFwZSBmdW5jdGlvbiBiKHIpICopXG4gICAgICAgICAgaWYgY29vcmQgPSBSIHRoZW5cbiAgICAgICAgICAgIG11bCAoRnVuYyAoXCJiJ1wiLCBhcmcpKSAoZCBhcmcpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgemVyb1xuICAgICAgfCBfIC0+IFBhcnRpYWwgKGV4cHIsIGNvb3JkKSAgKCogVW5rbm93biBmdW5jdGlvbiwgbGVhdmUgc3ltYm9saWMgKilcbiAgICAgIGVuZFxuICB8IE5lZyBlIC0+IG5lZyAoZCBlKVxuICB8IEFkZCAoYSwgYikgLT4gYWRkIChkIGEpIChkIGIpXG4gIHwgU3ViIChhLCBiKSAtPiBzdWIgKGQgYSkgKGQgYilcbiAgfCBNdWwgKGEsIGIpIC0+IGFkZCAobXVsIChkIGEpIGIpIChtdWwgYSAoZCBiKSkgICgqIFByb2R1Y3QgcnVsZSAqKVxuICB8IERpdiAoYSwgYikgLT4gKCogUXVvdGllbnQgcnVsZTogKGEvYiknID0gKGEnYiAtIGFiJykvYsKyICopXG4gICAgICBkaXYgKHN1YiAobXVsIChkIGEpIGIpIChtdWwgYSAoZCBiKSkpIChwb3cgYiB0d28pXG4gIHwgUG93IChiYXNlLCBOdW0gbikgLT4gKCogUG93ZXIgcnVsZTogKHhebiknID0gbip4XihuLTEpKngnICopXG4gICAgICBtdWwgKG11bCAoTnVtIG4pIChwb3cgYmFzZSAoTnVtIChuIC0uIDEuMCkpKSkgKGQgYmFzZSlcbiAgfCBQb3cgKGJhc2UsIGV4cCkgLT4gKCogR2VuZXJhbDogKGZeZyknID0gZl5nICogKGcnKmxuKGYpICsgZypmJy9mKSAqKVxuICAgICAgbGV0IHRlcm0xID0gbXVsIChkIGV4cCkgKGxvZ19leHByIGJhc2UpIGluXG4gICAgICBsZXQgdGVybTIgPSBtdWwgZXhwIChkaXYgKGQgYmFzZSkgYmFzZSkgaW5cbiAgICAgIG11bCAocG93IGJhc2UgZXhwKSAoYWRkIHRlcm0xIHRlcm0yKVxuICB8IEV4cCBlIC0+IG11bCAoRXhwIGUpIChkIGUpICAoKiAoZV5mKScgPSBlXmYgKiBmJyAqKVxuICB8IExvZyBlIC0+IGRpdiAoZCBlKSBlICAgICAgICAoKiAobG4gZiknID0gZicvZiAqKVxuICB8IFNpbiBlIC0+IG11bCAoQ29zIGUpIChkIGUpICAoKiAoc2luIGYpJyA9IGNvcyhmKSAqIGYnICopXG4gIHwgQ29zIGUgLT4gbmVnIChtdWwgKFNpbiBlKSAoZCBlKSkgICgqIChjb3MgZiknID0gLXNpbihmKSAqIGYnICopXG4gIHwgU3FydCBlIC0+IGRpdiAoZCBlKSAobXVsIHR3byAoU3FydCBlKSkgICgqICjiiJpmKScgPSBmJy8oMuKImmYpICopXG4gIHwgRGVsdGEgKF8sIF8pIC0+IHplcm8gICgqIEtyb25lY2tlciBkZWx0YSBpcyBjb25zdGFudCAqKVxuICB8IFBhcnRpYWwgKF8sIF8pIC0+IFBhcnRpYWwgKGV4cHIsIGNvb3JkKSAgKCogQ2FuJ3Qgc2ltcGxpZnkgZnVydGhlciAqKVxuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIFNJTVBMSUZJQ0FUSU9OXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxubGV0IHJlYyBzaW1wbGlmeSBleHByID1cbiAgbGV0IHMgPSBzaW1wbGlmeSBpblxuICBtYXRjaCBleHByIHdpdGhcbiAgfCBOdW0gXyB8IFZhciBfIHwgRGVsdGEgXyAtPiBleHByXG4gIHwgRnVuYyAobmFtZSwgZSkgLT4gRnVuYyAobmFtZSwgcyBlKVxuICB8IE5lZyBlIC0+IG5lZyAocyBlKVxuICB8IEFkZCAoYSwgYikgLT4gYWRkIChzIGEpIChzIGIpXG4gIHwgU3ViIChhLCBiKSAtPiBzdWIgKHMgYSkgKHMgYilcbiAgfCBNdWwgKGEsIGIpIC0+IG11bCAocyBhKSAocyBiKVxuICB8IERpdiAoYSwgYikgLT4gZGl2IChzIGEpIChzIGIpXG4gIHwgUG93IChhLCBiKSAtPiBwb3cgKHMgYSkgKHMgYilcbiAgfCBFeHAgZSAtPiBleHBfZXhwciAocyBlKVxuICB8IExvZyBlIC0+IGxvZ19leHByIChzIGUpXG4gIHwgU2luIGUgLT4gc2luX2V4cHIgKHMgZSlcbiAgfCBDb3MgZSAtPiBjb3NfZXhwciAocyBlKVxuICB8IFNxcnQgZSAtPiBzcXJ0X2V4cHIgKHMgZSlcbiAgfCBQYXJ0aWFsIChlLCBjKSAtPiBcbiAgICAgIGxldCBzZSA9IHMgZSBpblxuICAgICAgaWYgZGVwZW5kc19vbiBjIHNlIHRoZW5cbiAgICAgICAgc2ltcGxpZnkgKGRpZmZlcmVudGlhdGUgYyBzZSlcbiAgICAgIGVsc2VcbiAgICAgICAgemVyb1xuXG4oKiBGdWxseSBzaW1wbGlmeSBieSBpdGVyYXRpbmcgdW50aWwgZml4ZWQgcG9pbnQgKilcbmxldCByZWMgZnVsbF9zaW1wbGlmeSBleHByID1cbiAgbGV0IHMgPSBzaW1wbGlmeSBleHByIGluXG4gIGlmIHMgPSBleHByIHRoZW4gcyBlbHNlIGZ1bGxfc2ltcGxpZnkgc1xuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIFBSRVRUWSBQUklOVElOR1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICopXG5cbmxldCByZWMgdG9fc3RyaW5nIGV4cHIgPVxuICBtYXRjaCBleHByIHdpdGhcbiAgfCBOdW0gbiAtPiBcbiAgICAgIGlmIG4gPSBGbG9hdC5yb3VuZCBuIHRoZW4gc3RyaW5nX29mX2ludCAoaW50X29mX2Zsb2F0IG4pXG4gICAgICBlbHNlIFByaW50Zi5zcHJpbnRmIFwiJS40Z1wiIG5cbiAgfCBWYXIgcyAtPiBzXG4gIHwgRnVuYyAobmFtZSwgYXJnKSAtPiBQcmludGYuc3ByaW50ZiBcIiVzKCVzKVwiIG5hbWUgKHRvX3N0cmluZyBhcmcpXG4gIHwgTmVnIGUgLT4gUHJpbnRmLnNwcmludGYgXCItJXNcIiAodG9fc3RyaW5nX3BhcmVucyBlKVxuICB8IEFkZCAoYSwgYikgLT4gUHJpbnRmLnNwcmludGYgXCIlcyArICVzXCIgKHRvX3N0cmluZyBhKSAodG9fc3RyaW5nIGIpXG4gIHwgU3ViIChhLCBiKSAtPiBQcmludGYuc3ByaW50ZiBcIiVzIC0gJXNcIiAodG9fc3RyaW5nIGEpICh0b19zdHJpbmdfcGFyZW5zIGIpXG4gIHwgTXVsIChhLCBiKSAtPiBQcmludGYuc3ByaW50ZiBcIiVzwrclc1wiICh0b19zdHJpbmdfcGFyZW5zIGEpICh0b19zdHJpbmdfcGFyZW5zIGIpXG4gIHwgRGl2IChhLCBiKSAtPiBQcmludGYuc3ByaW50ZiBcIiVzLyVzXCIgKHRvX3N0cmluZ19wYXJlbnMgYSkgKHRvX3N0cmluZ19wYXJlbnMgYilcbiAgfCBQb3cgKGEsIGIpIC0+IFByaW50Zi5zcHJpbnRmIFwiJXNeJXNcIiAodG9fc3RyaW5nX3BhcmVucyBhKSAodG9fc3RyaW5nX3BhcmVucyBiKVxuICB8IEV4cCBlIC0+IFByaW50Zi5zcHJpbnRmIFwiZXhwKCVzKVwiICh0b19zdHJpbmcgZSlcbiAgfCBMb2cgZSAtPiBQcmludGYuc3ByaW50ZiBcImxuKCVzKVwiICh0b19zdHJpbmcgZSlcbiAgfCBTaW4gZSAtPiBQcmludGYuc3ByaW50ZiBcInNpbiglcylcIiAodG9fc3RyaW5nIGUpXG4gIHwgQ29zIGUgLT4gUHJpbnRmLnNwcmludGYgXCJjb3MoJXMpXCIgKHRvX3N0cmluZyBlKVxuICB8IFNxcnQgZSAtPiBQcmludGYuc3ByaW50ZiBcIuKImiglcylcIiAodG9fc3RyaW5nIGUpXG4gIHwgRGVsdGEgKGEsIGIpIC0+IFByaW50Zi5zcHJpbnRmIFwizrRfJXNeJXNcIiAoY29vcmRfdG9fc3RyaW5nIGEpIChjb29yZF90b19zdHJpbmcgYilcbiAgfCBQYXJ0aWFsIChlLCBjKSAtPiBQcmludGYuc3ByaW50ZiBcIuKIgl8lcyglcylcIiAoY29vcmRfdG9fc3RyaW5nIGMpICh0b19zdHJpbmcgZSlcblxuYW5kIHRvX3N0cmluZ19wYXJlbnMgZXhwciA9XG4gIG1hdGNoIGV4cHIgd2l0aFxuICB8IEFkZCBfIHwgU3ViIF8gLT4gUHJpbnRmLnNwcmludGYgXCIoJXMpXCIgKHRvX3N0cmluZyBleHByKVxuICB8IF8gLT4gdG9fc3RyaW5nIGV4cHJcblxubGV0IHJlYyB0b19sYXRleCBleHByID1cbiAgbWF0Y2ggZXhwciB3aXRoXG4gIHwgTnVtIG4gLT4gXG4gICAgICBpZiBuID0gRmxvYXQucm91bmQgbiB0aGVuIHN0cmluZ19vZl9pbnQgKGludF9vZl9mbG9hdCBuKVxuICAgICAgZWxzZSBQcmludGYuc3ByaW50ZiBcIiUuNGdcIiBuXG4gIHwgVmFyIFwizrhcIiAtPiBcIlxcXFx0aGV0YVwiXG4gIHwgVmFyIFwiz4ZcIiAtPiBcIlxcXFxwaGlcIlxuICB8IFZhciBzIC0+IHNcbiAgfCBGdW5jIChuYW1lLCBhcmcpIC0+IFByaW50Zi5zcHJpbnRmIFwiJXMoJXMpXCIgbmFtZSAodG9fbGF0ZXggYXJnKVxuICB8IE5lZyBlIC0+IFByaW50Zi5zcHJpbnRmIFwiLSVzXCIgKHRvX2xhdGV4X3BhcmVucyBlKVxuICB8IEFkZCAoYSwgYikgLT4gUHJpbnRmLnNwcmludGYgXCIlcyArICVzXCIgKHRvX2xhdGV4IGEpICh0b19sYXRleCBiKVxuICB8IFN1YiAoYSwgYikgLT4gUHJpbnRmLnNwcmludGYgXCIlcyAtICVzXCIgKHRvX2xhdGV4IGEpICh0b19sYXRleF9wYXJlbnMgYilcbiAgfCBNdWwgKGEsIGIpIC0+IFByaW50Zi5zcHJpbnRmIFwiJXMgXFxcXGNkb3QgJXNcIiAodG9fbGF0ZXhfcGFyZW5zIGEpICh0b19sYXRleF9wYXJlbnMgYilcbiAgfCBEaXYgKGEsIGIpIC0+IFByaW50Zi5zcHJpbnRmIFwiXFxcXGZyYWN7JXN9eyVzfVwiICh0b19sYXRleCBhKSAodG9fbGF0ZXggYilcbiAgfCBQb3cgKGEsIGIpIC0+IFByaW50Zi5zcHJpbnRmIFwiJXNeeyVzfVwiICh0b19sYXRleF9wYXJlbnMgYSkgKHRvX2xhdGV4IGIpXG4gIHwgRXhwIGUgLT4gUHJpbnRmLnNwcmludGYgXCJlXnslc31cIiAodG9fbGF0ZXggZSlcbiAgfCBMb2cgZSAtPiBQcmludGYuc3ByaW50ZiBcIlxcXFxsbiglcylcIiAodG9fbGF0ZXggZSlcbiAgfCBTaW4gZSAtPiBQcmludGYuc3ByaW50ZiBcIlxcXFxzaW4oJXMpXCIgKHRvX2xhdGV4IGUpXG4gIHwgQ29zIGUgLT4gUHJpbnRmLnNwcmludGYgXCJcXFxcY29zKCVzKVwiICh0b19sYXRleCBlKVxuICB8IFNxcnQgZSAtPiBQcmludGYuc3ByaW50ZiBcIlxcXFxzcXJ0eyVzfVwiICh0b19sYXRleCBlKVxuICB8IERlbHRhIChhLCBiKSAtPiBQcmludGYuc3ByaW50ZiBcIlxcXFxkZWx0YV57JXN9X3slc31cIiAoY29vcmRfdG9fbGF0ZXggYSkgKGNvb3JkX3RvX2xhdGV4IGIpXG4gIHwgUGFydGlhbCAoZSwgYykgLT4gUHJpbnRmLnNwcmludGYgXCJcXFxccGFydGlhbF97JXN9KCVzKVwiIChjb29yZF90b19sYXRleCBjKSAodG9fbGF0ZXggZSlcblxuYW5kIHRvX2xhdGV4X3BhcmVucyBleHByID1cbiAgbWF0Y2ggZXhwciB3aXRoXG4gIHwgQWRkIF8gfCBTdWIgXyAtPiBQcmludGYuc3ByaW50ZiBcIlxcXFxsZWZ0KCVzXFxcXHJpZ2h0KVwiICh0b19sYXRleCBleHByKVxuICB8IF8gLT4gdG9fbGF0ZXggZXhwclxuIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
