// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cmo, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Dune__exe__Simplify
//# unitInfo: Requires: Dune__exe__Expr, Stdlib, Stdlib__Float, Stdlib__Hashtbl, Stdlib__List, Stdlib__Map, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "\xce\xb8",
    cst$0 = "\xcf\x86",
    cst_r = "r",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    test_points =
      [0,
       [0, [0, cst_r, 2.], [0, [0, cst, 1.], [0, [0, cst$0, 0.5], 0]]],
       [0,
        [0, [0, cst_r, 3.], [0, [0, cst, 0.7], [0, [0, cst$0, 1.], 0]]],
        [0,
         [0, [0, cst_r, 1.5], [0, [0, cst, 1.5], [0, [0, cst$0, 0.2], 0]]],
         [0,
          [0, [0, cst_r, 5.], [0, [0, cst, 0.5], [0, [0, cst$0, 2.], 0]]],
          0]]]],
    Dune_exe_Expr = global_data.Dune__exe__Expr,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Float = global_data.Stdlib__Float,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Map = global_data.Stdlib__Map;
   function is_atom(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 1;
      case 5:
       return 1;
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
       return 1;
      default: return 0;
    }
   }
   function expr_key(e){return caml_call1(Dune_exe_Expr[25], e);}
   function expr_equal(a, b){
    var _X_ = expr_key(b);
    return expr_key(a) === _X_ ? 1 : 0;
   }
   var
    AtomMap = caml_call1(Stdlib_Map[1], [0, Stdlib_String[10]]),
    mono_one = [0, 1., AtomMap[1], AtomMap[1]];
   function mono_is_one(m){
    var _W_ = m[1] === 1. ? 1 : 0;
    return _W_ ? caml_call1(AtomMap[31], m[2]) : _W_;
   }
   function mono_is_zero(m){return Math.abs(m[1]) < 1e-15 ? 1 : 0;}
   function mono_mul(m1, m2){
    if(! mono_is_zero(m1) && ! mono_is_zero(m2)){
     var
      _T_ =
        caml_call3
         (AtomMap[8], function(_V_, e1, param){return [0, e1];}, m1[3], m2[3]),
      _U_ =
        caml_call3
         (AtomMap[8],
          function(param, e1, e2){
           var sum = e1 + e2 | 0;
           return 0 === sum ? 0 : [0, sum];
          },
          m1[2],
          m2[2]);
     return [0, m1[1] * m2[1], _U_, _T_];
    }
    return [0, 0., mono_one[2], mono_one[3]];
   }
   function mono_to_expr(m){
    if(mono_is_zero(m)) return Dune_exe_Expr[4];
    var
     factors =
       caml_call3
        (AtomMap[24],
         function(key, exp, acc){
          var
           atom = caml_call2(AtomMap[17], key, m[3]),
           factor =
             1 === exp
              ? atom
              : -1
                === exp
                ? [7, Dune_exe_Expr[5], atom]
                : 0
                  < exp
                  ? [8, atom, [0, exp]]
                  : [7, Dune_exe_Expr[5], [8, atom, [0, - exp | 0]]];
          return [0, factor, acc];
         },
         m[2],
         0);
    if(! factors) return [0, m[1]];
    var
     _R_ = caml_call1(Stdlib_List[7], factors),
     _S_ = caml_call1(Stdlib_List[6], factors),
     product =
       caml_call3
        (Stdlib_List[26], function(acc, f){return [6, acc, f];}, _S_, _R_);
    return m[1] === 1.
            ? product
            : m[1] === -1. ? [3, product] : [6, [0, m[1]], product];
   }
   var poly_zero = 0, poly_one = [0, mono_one, 0];
   function poly_normalize(p){
    var table = caml_call2(Stdlib_Hashtbl[1], 0, 16);
    caml_call2
     (Stdlib_List[18],
      function(m){
       var _L_ = 1 - mono_is_zero(m);
       if(! _L_) return _L_;
       var key = caml_call1(AtomMap[10], m[2]);
       try{
        var
         _N_ = caml_call2(Stdlib_Hashtbl[6], table, key),
         _O_ = _N_[2],
         _P_ = _N_[1],
         curr_e = _O_,
         curr_c = _P_;
       }
       catch(_Q_){
        var _M_ = caml_wrap_exception(_Q_);
        if(_M_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_M_, 0);
        var curr_e = m[3], curr_c = 0.;
       }
       return caml_call3
               (Stdlib_Hashtbl[11], table, key, [0, curr_c + m[1], curr_e]);
      },
      p);
    return caml_call3
            (Stdlib_Hashtbl[14],
             function(key, param, acc){
              var exprs = param[2], c = param[1];
              if(Math.abs(c) < 1e-15) return acc;
              var
               atoms =
                 caml_call3
                  (Stdlib_List[26],
                   function(m, param){
                    var v = param[2], k = param[1];
                    return caml_call3(AtomMap[2], k, v, m);
                   },
                   AtomMap[1],
                   key);
              return [0, [0, c, atoms, exprs], acc];
             },
             table,
             0);
   }
   function poly_add(p1, p2){
    return poly_normalize(caml_call2(Stdlib[37], p1, p2));
   }
   function poly_neg(p){
    return caml_call2
            (Stdlib_List[20], function(m){return [0, - m[1], m[2], m[3]];}, p);
   }
   function poly_sub(p1, p2){return poly_add(p1, poly_neg(p2));}
   function poly_mul(p1, p2){
    var
     terms =
       caml_call2
        (Stdlib_List[24],
         function(m1){
          return caml_call2
                  (Stdlib_List[20],
                   function(m2){return mono_mul(m1, m2);},
                   p2);
         },
         p1);
    return poly_normalize(terms);
   }
   function poly_is_zero(p){return 0 === poly_normalize(p) ? 1 : 0;}
   function poly_to_expr(p){
    var p$0 = poly_normalize(p);
    if(! p$0) return Dune_exe_Expr[4];
    var m = p$0[1];
    if(! p$0[2]) return mono_to_expr(m);
    var rest = p$0[2], _K_ = mono_to_expr(m);
    return caml_call3
            (Stdlib_List[26],
             function(acc, m){
              return 0. < m[1]
                      ? [4, acc, mono_to_expr(m)]
                      : [5, acc, mono_to_expr([0, - m[1], m[2], m[3]])];
             },
             _K_,
             rest);
   }
   function mono_from_atom(e){
    var
     _H_ = expr_key(e),
     _I_ = caml_call2(AtomMap[5], _H_, e),
     _J_ = expr_key(e);
    return [0, 1., caml_call2(AtomMap[5], _J_, 1), _I_];
   }
   function mono_const(c){return [0, c, mono_one[2], mono_one[3]];}
   function expr_to_poly(e){
    switch(e[0]){
      case 0:
       var n = e[1]; return Math.abs(n) < 1e-15 ? 0 : [0, mono_const(n), 0];
      case 1:
       return [0, mono_from_atom(e), 0];
      case 2:
       return [0, mono_from_atom(e), 0];
      case 3:
       var e1 = e[1]; return poly_neg(expr_to_poly(e1));
      case 4:
       var b = e[2], a = e[1], _E_ = expr_to_poly(b);
       return poly_add(expr_to_poly(a), _E_);
      case 5:
       var b$0 = e[2], a$0 = e[1], _F_ = expr_to_poly(b$0);
       return poly_sub(expr_to_poly(a$0), _F_);
      case 6:
       var b$1 = e[2], a$1 = e[1], _G_ = expr_to_poly(b$1);
       return poly_mul(expr_to_poly(a$1), _G_);
      case 7:
       return [0, mono_from_atom(e), 0];
      case 8:
       var base = e[1], match = e[2];
       if(0 === match[0]){
        var n$0 = match[1];
        if(1. <= n$0 && n$0 === Math.floor(n$0)){
         var
          pb = expr_to_poly(base),
          pow_n =
            function(p, k){
             return 1 === k ? p : poly_mul(p, pow_n(p, k - 1 | 0));
            };
         return pow_n(pb, n$0 | 0);
        }
       }
       return [0, mono_from_atom(e), 0];
      case 14:
       var b$2 = e[2], a$2 = e[1];
       return a$2 === b$2 ? [0, mono_const(1.), 0] : 0;
      case 15:
       return [0, mono_from_atom(e), 0];
      default: return [0, mono_from_atom(e), 0];
    }
   }
   function rat_poly(p){return [0, p, poly_one];}
   var rat_one = [0, poly_one, poly_one], rat_zero = [0, poly_zero, poly_one];
   function rat_add(r1, r2){
    var _C_ = poly_mul(r1[2], r2[2]), _D_ = poly_mul(r2[1], r1[2]);
    return [0, poly_add(poly_mul(r1[1], r2[2]), _D_), _C_];
   }
   function rat_neg(r){var _B_ = r[2]; return [0, poly_neg(r[1]), _B_];}
   function rat_sub(r1, r2){return rat_add(r1, rat_neg(r2));}
   function rat_mul(r1, r2){
    var _A_ = poly_mul(r1[2], r2[2]);
    return [0, poly_mul(r1[1], r2[1]), _A_];
   }
   function rat_div(r1, r2){
    var _z_ = poly_mul(r1[2], r2[1]);
    return [0, poly_mul(r1[1], r2[2]), _z_];
   }
   function rat_to_expr(r){
    var n = poly_to_expr(r[1]), d = poly_to_expr(r[2]);
    if(0 === d[0] && d[1] === 1.) return n;
    if(0 === n[0] && n[1] === 0.) return Dune_exe_Expr[4];
    return [7, n, d];
   }
   function expr_to_rational(e){
    switch(e[0]){
      case 0:
       var n = e[1], p = expr_to_poly([0, n]); return [0, p, poly_one];
      case 3:
       var e1 = e[1]; return rat_neg(expr_to_rational(e1));
      case 4:
       var b = e[2], a = e[1], _v_ = expr_to_rational(b);
       return rat_add(expr_to_rational(a), _v_);
      case 5:
       var b$0 = e[2], a$0 = e[1], _w_ = expr_to_rational(b$0);
       return rat_sub(expr_to_rational(a$0), _w_);
      case 6:
       var b$1 = e[2], a$1 = e[1], _x_ = expr_to_rational(b$1);
       return rat_mul(expr_to_rational(a$1), _x_);
      case 7:
       var b$2 = e[2], a$2 = e[1], _y_ = expr_to_rational(b$2);
       return rat_div(expr_to_rational(a$2), _y_);
      case 8:
       var base = e[1], match = e[2];
       if(0 === match[0]){
        var n$0 = match[1];
        if(1. <= n$0 && n$0 === Math.floor(n$0)){
         var
          rb = expr_to_rational(base),
          pow_n =
            function(r, k){
             return 1 === k ? r : rat_mul(r, pow_n(r, k - 1 | 0));
            };
         return pow_n(rb, n$0 | 0);
        }
        if(n$0 <= -1. && n$0 === Math.floor(n$0)){
         var
          rb$0 = expr_to_rational(base),
          pow_n$0 =
            function(r, k){
             return 1 === k ? r : rat_mul(r, pow_n$0(r, k - 1 | 0));
            },
          pos_pow = pow_n$0(rb$0, - n$0 | 0);
         return [0, pos_pow[2], pos_pow[1]];
        }
       }
       var p$1 = [0, mono_from_atom(e), 0];
       return [0, p$1, poly_one];
      case 14:
       var b$3 = e[2], a$3 = e[1]; return a$3 === b$3 ? rat_one : rat_zero;
      case 15:
       var p$2 = [0, mono_from_atom(e), 0]; return [0, p$2, poly_one];
      default: var p$0 = expr_to_poly(e); return [0, p$0, poly_one];
    }
   }
   function simplify_via_rational(e){
    var r = expr_to_rational(e);
    return rat_to_expr(r);
   }
   function simplify_structural(e){
    var e$0 = e;
    for(;;)
     switch(e$0[0]){
       case 2:
        var arg = e$0[2], name = e$0[1];
        return [2, name, simplify_structural(arg)];
       case 3:
        var e1 = e$0[1];
        switch(e1[0]){
          case 0:
           var n = e1[1]; return [0, - n];
          case 3:
           var e1$0 = e1[1]; e$0 = e1$0; break;
          default: return [3, simplify_structural(e1)];
        }
        break;
       case 4:
        var e1$1 = e$0[1];
        a:
        {
         if(0 === e1$1[0] && e1$1[1] === 0.){var e1$3 = e$0[2]; break a;}
         var match = e$0[2];
         switch(match[0]){
           case 0:
            if(match[1] === 0.){var e1$3 = e1$1; break a;} break;
           case 3:
            var e2$0 = match[1];
            if(expr_equal(e1$1, e2$0)) return Dune_exe_Expr[4];
            break;
         }
         switch(e1$1[0]){
           case 0:
            var match$0 = e$0[2];
            if(0 === match$0[0]){
             var b = match$0[1], a = e1$1[1];
             return [0, a + b];
            }
            break;
           case 3:
            var e2 = e$0[2], e1$2 = e1$1[1];
            if(expr_equal(e1$2, e2)) return Dune_exe_Expr[4];
            break;
         }
         var b$0 = e$0[2], _k_ = simplify_structural(b$0);
         return [4, simplify_structural(e1$1), _k_];
        }
        e$0 = e1$3;
        break;
       case 5:
        var e1$4 = e$0[1];
        if(0 === e1$4[0]){
         var match$1 = e$0[2];
         if(0 === match$1[0]){
          var b$1 = match$1[1], a$0 = e1$4[1];
          return [0, a$0 - b$1];
         }
        }
        else{
         var _m_ = e$0[2];
         if(0 === _m_[0] && _m_[1] === 0.){e$0 = e1$4; break;}
        }
        if(0 === e1$4[0] && e1$4[1] === 0.){
         var e1$5 = e$0[2];
         return [3, simplify_structural(e1$5)];
        }
        var e2$1 = e$0[2];
        if(expr_equal(e1$4, e2$1)) return Dune_exe_Expr[4];
        if(4 === e1$4[0]){
         var a$1 = e1$4[1], c = e$0[2], b$3 = e1$4[2];
         if(expr_equal(a$1, c)){e$0 = b$3; break;}
         var c$0 = e$0[2], b$4 = e1$4[2];
         if(expr_equal(b$4, c$0)){e$0 = a$1; break;}
        }
        var b$2 = e$0[2], _l_ = simplify_structural(b$2);
        return [5, simplify_structural(e1$4), _l_];
       case 6:
        var e1$6 = e$0[1];
        a:
        {
         if(0 === e1$6[0] && e1$6[1] === 0.) break a;
         var _n_ = e$0[2];
         if(0 === _n_[0] && _n_[1] === 0.) break a;
         b:
         {
          if(0 === e1$6[0] && e1$6[1] === 1.){var e1$8 = e$0[2]; break b;}
          var _o_ = e$0[2];
          if(0 === _o_[0] && _o_[1] === 1.){var e1$8 = e1$6; break b;}
          if(0 === e1$6[0]){
           var a$2 = e1$6[1];
           if(a$2 === -1.){
            var e1$7 = e$0[2];
            return [3, simplify_structural(e1$7)];
           }
           var match$2 = e$0[2];
           if(0 === match$2[0]){var b$5 = match$2[1]; return [0, a$2 * b$5];}
          }
          var b$6 = e$0[2], _p_ = simplify_structural(b$6);
          return [6, simplify_structural(e1$6), _p_];
         }
         e$0 = e1$8;
         break;
        }
        return Dune_exe_Expr[4];
       case 7:
        var e1$9 = e$0[1];
        if(0 === e1$9[0] && e1$9[1] === 0.) return Dune_exe_Expr[4];
        var _q_ = e$0[2];
        if(0 === _q_[0]){
         if(_q_[1] === 1.){e$0 = e1$9; break;}
         if(0 === e1$9[0]){
          var b$7 = e$0[2][1], a$3 = e1$9[1];
          if(b$7 !== 0.) return [0, a$3 / b$7];
         }
        }
        var e2$2 = e$0[2];
        if(expr_equal(e1$9, e2$2)) return Dune_exe_Expr[5];
        var b$8 = e$0[2], _r_ = simplify_structural(b$8);
        return [7, simplify_structural(e1$9), _r_];
       case 8:
        var e1$10 = e$0[1], _s_ = e$0[2];
        if(0 === _s_[0]){
         var _t_ = _s_[1];
         if(_t_ === 0.) return Dune_exe_Expr[5];
         if(_t_ === 1.){e$0 = e1$10; break;}
        }
        if(0 === e1$10[0]){
         var a$4 = e1$10[1];
         if(a$4 === 1.) return Dune_exe_Expr[5];
         var match$3 = e$0[2];
         if(0 === match$3[0]){
          var b$9 = match$3[1];
          return [0, Math.pow(a$4, b$9)];
         }
        }
        var b$10 = e$0[2], _u_ = simplify_structural(b$10);
        return [8, simplify_structural(e1$10), _u_];
       case 9:
        var e1$11 = e$0[1];
        if(0 === e1$11[0] && e1$11[1] === 0.) return Dune_exe_Expr[5];
        return [9, simplify_structural(e1$11)];
       case 10:
        var e1$12 = e$0[1];
        if(0 === e1$12[0] && e1$12[1] === 1.) return Dune_exe_Expr[4];
        return [10, simplify_structural(e1$12)];
       case 11:
        var e1$13 = e$0[1];
        if(0 === e1$13[0] && e1$13[1] === 0.) return Dune_exe_Expr[4];
        return [11, simplify_structural(e1$13)];
       case 12:
        var e1$14 = e$0[1];
        if(0 === e1$14[0] && e1$14[1] === 0.) return Dune_exe_Expr[5];
        return [12, simplify_structural(e1$14)];
       case 13:
        var e1$15 = e$0[1];
        if(0 === e1$15[0]){
         var n$0 = e1$15[1];
         if(0. <= n$0) return [0, Math.sqrt(n$0)];
        }
        return [13, simplify_structural(e1$15)];
       case 15:
        var c$1 = e$0[2], e1$16 = e$0[1], s = simplify_structural(e1$16);
        if(! caml_call2(Dune_exe_Expr[21], c$1, s)) return Dune_exe_Expr[4];
        var e$1 = caml_call2(Dune_exe_Expr[22], c$1, s);
        e$0 = e$1;
        break;
       default: return e$0;
     }
   }
   function iterate_structural(e){
    var e$0 = e;
    for(;;){
     var s = simplify_structural(e$0);
     if(expr_equal(s, e$0)) return s;
     e$0 = s;
    }
   }
   function eval_at_point(e, bindings){
    switch(e[0]){
      case 0:
       var n = e[1]; return n;
      case 1:
       var name = e[1];
       try{var _d_ = caml_call2(Stdlib_List[49], name, bindings); return _d_;}
       catch(_j_){
        var _c_ = caml_wrap_exception(_j_);
        if(_c_ === Stdlib[8]) return Stdlib[24];
        throw caml_maybe_attach_backtrace(_c_, 0);
       }
      case 2:
       var _e_ = e[1];
       return _e_ !== "b"
               ? _e_
                 !== "b'"
                 ? _e_
                   !== "\xce\xa6"
                   ? _e_ !== "\xce\xa6'" ? Stdlib[24] : 0.
                   : 0.
                 : 0.
               : 1.;
      case 3:
       var e1 = e[1]; return - eval_at_point(e1, bindings);
      case 4:
       var b = e[2], a = e[1], _f_ = eval_at_point(b, bindings);
       return eval_at_point(a, bindings) + _f_;
      case 5:
       var b$0 = e[2], a$0 = e[1], _g_ = eval_at_point(b$0, bindings);
       return eval_at_point(a$0, bindings) - _g_;
      case 6:
       var b$1 = e[2], a$1 = e[1], _h_ = eval_at_point(b$1, bindings);
       return eval_at_point(a$1, bindings) * _h_;
      case 7:
       var b$2 = e[2], a$2 = e[1], d = eval_at_point(b$2, bindings);
       return Math.abs(d) < 1e-15
               ? Stdlib[24]
               : eval_at_point(a$2, bindings) / d;
      case 8:
       var b$3 = e[2], a$3 = e[1], _i_ = eval_at_point(b$3, bindings);
       return Math.pow(eval_at_point(a$3, bindings), _i_);
      case 9:
       var e1$0 = e[1]; return Math.exp(eval_at_point(e1$0, bindings));
      case 10:
       var e1$1 = e[1]; return Math.log(eval_at_point(e1$1, bindings));
      case 11:
       var e1$2 = e[1]; return Math.sin(eval_at_point(e1$2, bindings));
      case 12:
       var e1$3 = e[1]; return Math.cos(eval_at_point(e1$3, bindings));
      case 13:
       var e1$4 = e[1]; return Math.sqrt(eval_at_point(e1$4, bindings));
      case 14:
       var b$4 = e[2], a$4 = e[1]; return a$4 === b$4 ? 1. : 0.;
      default: return Stdlib[24];
    }
   }
   function likely_zero(e){
    return caml_call2
            (Stdlib_List[33],
             function(bindings){
              var
               v = eval_at_point(e, bindings),
               _a_ = caml_call1(Stdlib_Float[17], v),
               _b_ = _a_ || (Math.abs(v) < 1e-10 ? 1 : 0);
              return _b_;
             },
             test_points);
   }
   function simplify_complete(e){
    var
     e1 = iterate_structural(e),
     e2 = simplify_via_rational(e1),
     e3 = iterate_structural(e2);
    return likely_zero(e3) ? Dune_exe_Expr[4] : e3;
   }
   var
    Dune_exe_Simplify =
      [0,
       is_atom,
       expr_key,
       expr_equal,
       AtomMap,
       mono_one,
       mono_is_one,
       mono_is_zero,
       mono_mul,
       mono_to_expr,
       poly_zero,
       poly_one,
       poly_normalize,
       poly_add,
       poly_neg,
       poly_sub,
       poly_mul,
       poly_is_zero,
       poly_to_expr,
       mono_from_atom,
       mono_const,
       expr_to_poly,
       rat_poly,
       rat_one,
       rat_zero,
       rat_add,
       rat_neg,
       rat_sub,
       rat_mul,
       rat_div,
       rat_to_expr,
       expr_to_rational,
       simplify_via_rational,
       simplify_structural,
       iterate_structural,
       test_points,
       eval_at_point,
       likely_zero,
       simplify_complete,
       simplify_complete,
       simplify_structural];
   runtime.caml_register_global(57, Dune_exe_Simplify, "Dune__exe__Simplify");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLmpzX2JyaWRnZS5lb2Jqcy9qc29vL2R1bmVfX2V4ZV9fU2ltcGxpZnkuY21vLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Ii5qc19icmlkZ2UuZW9ianMvanNvby9kdW5lX19leGVfX1NpbXBsaWZ5LmNtby5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjc3RfciIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJ0ZXN0X3BvaW50cyIsIkR1bmVfZXhlX0V4cHIiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYiIsIlN0ZGxpYl9GbG9hdCIsIlN0ZGxpYl9IYXNodGJsIiwiU3RkbGliX1N0cmluZyIsIlN0ZGxpYl9NYXAiLCJpc19hdG9tIiwicGFyYW0iLCJleHByX2tleSIsImUiLCJleHByX2VxdWFsIiwiYSIsImIiLCJBdG9tTWFwIiwibW9ub19vbmUiLCJtb25vX2lzX29uZSIsIm0iLCJtb25vX2lzX3plcm8iLCJtb25vX211bCIsIm0xIiwibTIiLCJlMSIsImUyIiwic3VtIiwibW9ub190b19leHByIiwiZmFjdG9ycyIsImtleSIsImV4cCIsImFjYyIsImF0b20iLCJmYWN0b3IiLCJwcm9kdWN0IiwicG9seV96ZXJvIiwicG9seV9vbmUiLCJwb2x5X25vcm1hbGl6ZSIsInAiLCJ0YWJsZSIsImN1cnJfZSIsImN1cnJfYyIsImV4cHJzIiwiYyIsImF0b21zIiwidiIsImsiLCJwb2x5X2FkZCIsInAxIiwicDIiLCJwb2x5X25lZyIsInBvbHlfc3ViIiwicG9seV9tdWwiLCJ0ZXJtcyIsInBvbHlfaXNfemVybyIsInBvbHlfdG9fZXhwciIsInJlc3QiLCJtb25vX2Zyb21fYXRvbSIsIm1vbm9fY29uc3QiLCJleHByX3RvX3BvbHkiLCJuIiwiYmFzZSIsIm1hdGNoIiwicGIiLCJwb3dfbiIsInJhdF9wb2x5IiwicmF0X29uZSIsInJhdF96ZXJvIiwicmF0X2FkZCIsInIxIiwicjIiLCJyYXRfbmVnIiwiciIsInJhdF9zdWIiLCJyYXRfbXVsIiwicmF0X2RpdiIsInJhdF90b19leHByIiwiZCIsImV4cHJfdG9fcmF0aW9uYWwiLCJyYiIsInBvc19wb3ciLCJzaW1wbGlmeV92aWFfcmF0aW9uYWwiLCJzaW1wbGlmeV9zdHJ1Y3R1cmFsIiwiYXJnIiwibmFtZSIsInMiLCJpdGVyYXRlX3N0cnVjdHVyYWwiLCJldmFsX2F0X3BvaW50IiwiYmluZGluZ3MiLCJsaWtlbHlfemVybyIsInNpbXBsaWZ5X2NvbXBsZXRlIiwiZTMiLCJEdW5lX2V4ZV9TaW1wbGlmeSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9zaW1wbGlmeS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFB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QUEsV0FBQUEsT0F0QmxCLE1Ba0JnQixPQUFKLFNBQUksOEJBSUU7QUFBQTtBQUFBLFdBQUFBLE9BdEJsQixNQW1CZ0IsT0FBSixTQUFJLDhCQUdFO0FBQUE7QUFBQSxXQUFBQSxPQXRCbEIsTUFvQmtCLE9BQUwsVUFBSyw4QkFFQTtBQUFBO0FBQUEsV0FBQVQsTUF0QmxCLE1BQUFELE1BQUEsTUFxQmtCLDRCQUNBO0FBQUEsZUFBSDtBQUFBO0FBQUEsR0FBRztBQUFBLFlBQUEyRSxZQUFBN0U7QUFBQUEsSUFHbEI7QUFBQTtBQUFBLHNCQUFBNEU7QUFBQUE7QUFBQUEsZUFBQTNDLElBQ1U7QUFBQSxxQkFDUjtBQUFBLHFCQUFjLFFBQUk7QUFBQSxjQUFKO0FBQUEsYUFBdUI7QUFBQSx5QkFDMUI7QUFBQTtBQUFBLFlBQUE2QyxrQkFBQTlFO0FBQUFBO0FBQUFBLEtBQUFZLEtBUUo7QUFBQSxLQUFBQyxLQUVBO0FBQUEsS0FBQWtFLEtBRUE7QUFBQSxJQUVOLDhDQUFnQztBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNRDFXckMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIHNpbXBsaWZ5Lm1sIC0gUHJvcGVyIENBUyBzaW1wbGlmaWNhdGlvbiB2aWEgY2Fub25pY2FsIGZvcm1zXG4gICBcbiAgIEJhc2VkIG9uOlxuICAgLSBNb3NlcywgXCJBbGdlYnJhaWMgU2ltcGxpZmljYXRpb246IEEgR3VpZGUgZm9yIHRoZSBQZXJwbGV4ZWRcIiAoMTk3MSlcbiAgIC0gU3ltUHkncyBjYW5jZWwoKSBhbmQgcG9seW5vbWlhbCBtb2R1bGVcbiAgIC0gU3RhbmRhcmQgQ0FTIHRoZW9yeSBmb3IgcmF0aW9uYWwgZnVuY3Rpb24gY2Fub25pY2FsaXphdGlvblxuICAgXG4gICBTdHJhdGVneTpcbiAgIDEuIFJlcHJlc2VudCBleHByZXNzaW9ucyBhcyByYXRpb25hbCBmdW5jdGlvbnMgUCh4KS9RKHgpXG4gICAyLiBQLCBRIGFyZSBwb2x5bm9taWFscyB3aGVyZSB2YXJpYWJsZXMgYXJlIFwiYXRvbXNcIiAoaW5jbHVkZXMgciwgzrgsIGIociksIHNpbijOuCksIGV0Yy4pXG4gICAzLiBDb21iaW5lIGZyYWN0aW9ucywgdGhlbiBjYW5jZWwgR0NEKFAsIFEpXG4gICA0LiBVc2UgbnVtZXJpY2FsIHRlc3RpbmcgdG8gZGV0ZWN0IHplcm8gZXhwcmVzc2lvbnNcbiopXG5cbm9wZW4gRXhwclxuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIFBPTFlOT01JQUwgUkVQUkVTRU5UQVRJT05cbiAgIFxuICAgQSBwb2x5bm9taWFsIG92ZXIgYXRvbXMgaXM6XG4gICAtIFN1bSBvZiB0ZXJtc1xuICAgLSBFYWNoIHRlcm0gaXM6IGNvZWZmaWNpZW50ICogcHJvZHVjdCBvZiAoYXRvbV5wb3dlcilcbiAgIC0gQXRvbXMgYXJlOiB2YXJpYWJsZXMsIGZ1bmN0aW9uIGFwcGxpY2F0aW9ucywgdHJhbnNjZW5kZW50YWxzXG4gICBcbiAgIFdlIERPTidUIGV4cGFuZCAociAtIGIocikpIC0gd2UgdHJlYXQgaXQgYXMgYW4gYXRvbS5cbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG4oKiBBbiBhdG9tIGlzIGFueSBpcnJlZHVjaWJsZSBleHByZXNzaW9uIHVuaXQgKilcbmxldCBpc19hdG9tID0gZnVuY3Rpb25cbiAgfCBOdW0gXyAtPiBmYWxzZSAgKCogbnVtYmVycyBhcmUgY29lZmZpY2llbnRzLCBub3QgYXRvbXMgKilcbiAgfCBWYXIgXyAtPiB0cnVlXG4gIHwgRnVuYyBfIC0+IHRydWVcbiAgfCBTaW4gXyB8IENvcyBfIHwgRXhwIF8gfCBMb2cgXyB8IFNxcnQgXyAtPiB0cnVlXG4gIHwgU3ViIF8gLT4gdHJ1ZSAgICgqIFRyZWF0IChhIC0gYikgYXMgYXRvbSB0byBhdm9pZCBleHBhbnNpb24gYmxvd3VwICopXG4gIHwgXyAtPiBmYWxzZVxuXG4oKiBGb3IgZXhwcmVzc2lvbiBjb21wYXJpc29uL3NvcnRpbmcgKilcbmxldCBleHByX2tleSBlID0gdG9fc3RyaW5nIGVcbmxldCBleHByX2VxdWFsIGEgYiA9IGV4cHJfa2V5IGEgPSBleHByX2tleSBiXG5cbigqIE1vbm9taWFsOiBNYXAgZnJvbSBhdG9tIHRvIGludGVnZXIgcG93ZXIgKilcbm1vZHVsZSBBdG9tTWFwID0gTWFwLk1ha2UoU3RyaW5nKVxuXG50eXBlIG1vbm8gPSB7XG4gIGNvZWZmOiBmbG9hdDtcbiAgYXRvbXM6IGludCBBdG9tTWFwLnQ7ICAoKiBhdG9tX2tleSAtPiBleHBvbmVudCAqKVxuICBhdG9tX2V4cHJzOiBleHByIEF0b21NYXAudDsgICgqIGF0b21fa2V5IC0+IGFjdHVhbCBleHByLCBmb3IgcmVjb25zdHJ1Y3Rpb24gKilcbn1cblxubGV0IG1vbm9fb25lID0geyBjb2VmZiA9IDEuMDsgYXRvbXMgPSBBdG9tTWFwLmVtcHR5OyBhdG9tX2V4cHJzID0gQXRvbU1hcC5lbXB0eSB9XG5cbmxldCBtb25vX2lzX29uZSBtID0gbS5jb2VmZiA9IDEuMCAmJiBBdG9tTWFwLmlzX2VtcHR5IG0uYXRvbXNcbmxldCBtb25vX2lzX3plcm8gbSA9IGFic19mbG9hdCBtLmNvZWZmIDwgMWUtMTVcblxubGV0IG1vbm9fbXVsIG0xIG0yID0gXG4gIGlmIG1vbm9faXNfemVybyBtMSB8fCBtb25vX2lzX3plcm8gbTIgdGhlbiB7IG1vbm9fb25lIHdpdGggY29lZmYgPSAwLjAgfVxuICBlbHNlIHtcbiAgICBjb2VmZiA9IG0xLmNvZWZmICouIG0yLmNvZWZmO1xuICAgIGF0b21zID0gQXRvbU1hcC51bmlvbiAoZnVuIF8gZTEgZTIgLT4gXG4gICAgICBsZXQgc3VtID0gZTEgKyBlMiBpbiBpZiBzdW0gPSAwIHRoZW4gTm9uZSBlbHNlIFNvbWUgc3VtXG4gICAgKSBtMS5hdG9tcyBtMi5hdG9tcztcbiAgICBhdG9tX2V4cHJzID0gQXRvbU1hcC51bmlvbiAoZnVuIF8gZTEgXyAtPiBTb21lIGUxKSBtMS5hdG9tX2V4cHJzIG0yLmF0b21fZXhwcnM7XG4gIH1cblxubGV0IG1vbm9fdG9fZXhwciBtID1cbiAgaWYgbW9ub19pc196ZXJvIG0gdGhlbiB6ZXJvXG4gIGVsc2VcbiAgICBsZXQgZmFjdG9ycyA9IEF0b21NYXAuZm9sZCAoZnVuIGtleSBleHAgYWNjIC0+XG4gICAgICBsZXQgYXRvbSA9IEF0b21NYXAuZmluZCBrZXkgbS5hdG9tX2V4cHJzIGluXG4gICAgICBsZXQgZmFjdG9yID0gaWYgZXhwID0gMSB0aGVuIGF0b20gXG4gICAgICAgICAgICAgICAgICAgZWxzZSBpZiBleHAgPSAtMSB0aGVuIERpdiAob25lLCBhdG9tKVxuICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgZXhwID4gMCB0aGVuIFBvdyAoYXRvbSwgTnVtIChmbG9hdF9vZl9pbnQgZXhwKSlcbiAgICAgICAgICAgICAgICAgICBlbHNlIERpdiAob25lLCBQb3cgKGF0b20sIE51bSAoZmxvYXRfb2ZfaW50ICgtZXhwKSkpKSBpblxuICAgICAgZmFjdG9yIDo6IGFjY1xuICAgICkgbS5hdG9tcyBbXSBpblxuICAgIG1hdGNoIGZhY3RvcnMgd2l0aFxuICAgIHwgW10gLT4gTnVtIG0uY29lZmZcbiAgICB8IF8gLT5cbiAgICAgICAgbGV0IHByb2R1Y3QgPSBMaXN0LmZvbGRfbGVmdCAoZnVuIGFjYyBmIC0+IE11bCAoYWNjLCBmKSkgKExpc3QuaGQgZmFjdG9ycykgKExpc3QudGwgZmFjdG9ycykgaW5cbiAgICAgICAgaWYgbS5jb2VmZiA9IDEuMCB0aGVuIHByb2R1Y3RcbiAgICAgICAgZWxzZSBpZiBtLmNvZWZmID0gLTEuMCB0aGVuIE5lZyBwcm9kdWN0XG4gICAgICAgIGVsc2UgTXVsIChOdW0gbS5jb2VmZiwgcHJvZHVjdClcblxuKCogUG9seW5vbWlhbDogbGlzdCBvZiBtb25vbWlhbHMgKilcbnR5cGUgcG9seSA9IG1vbm8gbGlzdFxuXG5sZXQgcG9seV96ZXJvID0gW11cbmxldCBwb2x5X29uZSA9IFttb25vX29uZV1cblxuKCogTm9ybWFsaXplOiBjb21iaW5lIGxpa2UgdGVybXMgKilcbmxldCBwb2x5X25vcm1hbGl6ZSAocCA6IHBvbHkpIDogcG9seSA9XG4gIGxldCB0YWJsZSA9IEhhc2h0YmwuY3JlYXRlIDE2IGluXG4gIExpc3QuaXRlciAoZnVuIG0gLT5cbiAgICBpZiBub3QgKG1vbm9faXNfemVybyBtKSB0aGVuIGJlZ2luXG4gICAgICBsZXQga2V5ID0gQXRvbU1hcC5iaW5kaW5ncyBtLmF0b21zIGluXG4gICAgICBsZXQgKGN1cnJfYywgY3Vycl9lKSA9IHRyeSBIYXNodGJsLmZpbmQgdGFibGUga2V5IHdpdGggTm90X2ZvdW5kIC0+ICgwLjAsIG0uYXRvbV9leHBycykgaW5cbiAgICAgIEhhc2h0YmwucmVwbGFjZSB0YWJsZSBrZXkgKGN1cnJfYyArLiBtLmNvZWZmLCBjdXJyX2UpXG4gICAgZW5kXG4gICkgcDtcbiAgSGFzaHRibC5mb2xkIChmdW4ga2V5IChjLCBleHBycykgYWNjIC0+XG4gICAgaWYgYWJzX2Zsb2F0IGMgPCAxZS0xNSB0aGVuIGFjY1xuICAgIGVsc2UgXG4gICAgICBsZXQgYXRvbXMgPSBMaXN0LmZvbGRfbGVmdCAoZnVuIG0gKGssIHYpIC0+IEF0b21NYXAuYWRkIGsgdiBtKSBBdG9tTWFwLmVtcHR5IGtleSBpblxuICAgICAgeyBjb2VmZiA9IGM7IGF0b21zOyBhdG9tX2V4cHJzID0gZXhwcnMgfSA6OiBhY2NcbiAgKSB0YWJsZSBbXVxuXG5sZXQgcG9seV9hZGQgcDEgcDIgPSBwb2x5X25vcm1hbGl6ZSAocDEgQCBwMilcbmxldCBwb2x5X25lZyBwID0gTGlzdC5tYXAgKGZ1biBtIC0+IHsgbSB3aXRoIGNvZWZmID0gLS4gbS5jb2VmZiB9KSBwXG5sZXQgcG9seV9zdWIgcDEgcDIgPSBwb2x5X2FkZCBwMSAocG9seV9uZWcgcDIpXG5cbmxldCBwb2x5X211bCBwMSBwMiA9XG4gIGxldCB0ZXJtcyA9IExpc3QuY29uY2F0X21hcCAoZnVuIG0xIC0+XG4gICAgTGlzdC5tYXAgKGZ1biBtMiAtPiBtb25vX211bCBtMSBtMikgcDJcbiAgKSBwMSBpblxuICBwb2x5X25vcm1hbGl6ZSB0ZXJtc1xuXG5sZXQgcG9seV9pc196ZXJvIHAgPSAocG9seV9ub3JtYWxpemUgcCA9IFtdKVxuXG5sZXQgcG9seV90b19leHByIChwIDogcG9seSkgOiBleHByID1cbiAgbGV0IHAgPSBwb2x5X25vcm1hbGl6ZSBwIGluXG4gIG1hdGNoIHAgd2l0aFxuICB8IFtdIC0+IHplcm9cbiAgfCBbbV0gLT4gbW9ub190b19leHByIG1cbiAgfCBtIDo6IHJlc3QgLT5cbiAgICAgIExpc3QuZm9sZF9sZWZ0IChmdW4gYWNjIG0gLT5cbiAgICAgICAgaWYgbS5jb2VmZiA+IDAuMCB0aGVuIEFkZCAoYWNjLCBtb25vX3RvX2V4cHIgbSlcbiAgICAgICAgZWxzZSBTdWIgKGFjYywgbW9ub190b19leHByIHsgbSB3aXRoIGNvZWZmID0gLS4gbS5jb2VmZiB9KVxuICAgICAgKSAobW9ub190b19leHByIG0pIHJlc3RcblxuKCogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICBDT05WRVJUIEVYUFIgVE8gUE9MWU5PTUlBTFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICopXG5cbmxldCBtb25vX2Zyb21fYXRvbSBlID0ge1xuICBjb2VmZiA9IDEuMDtcbiAgYXRvbXMgPSBBdG9tTWFwLnNpbmdsZXRvbiAoZXhwcl9rZXkgZSkgMTtcbiAgYXRvbV9leHBycyA9IEF0b21NYXAuc2luZ2xldG9uIChleHByX2tleSBlKSBlO1xufVxuXG5sZXQgbW9ub19jb25zdCBjID0geyBtb25vX29uZSB3aXRoIGNvZWZmID0gYyB9XG5cbmxldCByZWMgZXhwcl90b19wb2x5IChlIDogZXhwcikgOiBwb2x5ID1cbiAgbWF0Y2ggZSB3aXRoXG4gIHwgTnVtIG4gLT4gaWYgYWJzX2Zsb2F0IG4gPCAxZS0xNSB0aGVuIFtdIGVsc2UgW21vbm9fY29uc3Qgbl1cbiAgfCBWYXIgXyAtPiBbbW9ub19mcm9tX2F0b20gZV1cbiAgfCBGdW5jIF8gLT4gW21vbm9fZnJvbV9hdG9tIGVdXG4gIFxuICB8IE5lZyBlMSAtPiBwb2x5X25lZyAoZXhwcl90b19wb2x5IGUxKVxuICB8IEFkZCAoYSwgYikgLT4gcG9seV9hZGQgKGV4cHJfdG9fcG9seSBhKSAoZXhwcl90b19wb2x5IGIpXG4gIHwgU3ViIChhLCBiKSAtPiBwb2x5X3N1YiAoZXhwcl90b19wb2x5IGEpIChleHByX3RvX3BvbHkgYilcbiAgXG4gIHwgTXVsIChhLCBiKSAtPiBwb2x5X211bCAoZXhwcl90b19wb2x5IGEpIChleHByX3RvX3BvbHkgYilcbiAgXG4gIHwgRGl2IF8gLT4gW21vbm9fZnJvbV9hdG9tIGVdICAoKiBLZWVwIGZyYWN0aW9ucyBhcyBhdG9tcyBmb3Igbm93ICopXG4gIFxuICB8IFBvdyAoYmFzZSwgTnVtIG4pIHdoZW4gbiA+PSAxLjAgJiYgbiA9IGZsb29yIG4gLT5cbiAgICAgIGxldCBwYiA9IGV4cHJfdG9fcG9seSBiYXNlIGluXG4gICAgICBsZXQgcmVjIHBvd19uIHAgayA9IFxuICAgICAgICBpZiBrID0gMSB0aGVuIHAgXG4gICAgICAgIGVsc2UgcG9seV9tdWwgcCAocG93X24gcCAoay0xKSkgXG4gICAgICBpblxuICAgICAgcG93X24gcGIgKGludF9vZl9mbG9hdCBuKVxuICB8IFBvdyBfIC0+IFttb25vX2Zyb21fYXRvbSBlXVxuICBcbiAgfCBTaW4gXyB8IENvcyBfIHwgRXhwIF8gfCBMb2cgXyB8IFNxcnQgXyAtPiBbbW9ub19mcm9tX2F0b20gZV1cbiAgfCBEZWx0YSAoYSwgYikgLT4gaWYgYSA9IGIgdGhlbiBbbW9ub19jb25zdCAxLjBdIGVsc2UgW11cbiAgfCBQYXJ0aWFsIF8gLT4gW21vbm9fZnJvbV9hdG9tIGVdXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgUkFUSU9OQUwgRlVOQ1RJT046IG51bV9wb2x5IC8gZGVuX3BvbHlcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG50eXBlIHJhdGlvbmFsID0geyBudW06IHBvbHk7IGRlbjogcG9seSB9XG5cbmxldCByYXRfcG9seSBwID0geyBudW0gPSBwOyBkZW4gPSBwb2x5X29uZSB9XG5sZXQgcmF0X29uZSA9IHsgbnVtID0gcG9seV9vbmU7IGRlbiA9IHBvbHlfb25lIH1cbmxldCByYXRfemVybyA9IHsgbnVtID0gcG9seV96ZXJvOyBkZW4gPSBwb2x5X29uZSB9XG5cbmxldCByYXRfYWRkIHIxIHIyID0ge1xuICBudW0gPSBwb2x5X2FkZCAocG9seV9tdWwgcjEubnVtIHIyLmRlbikgKHBvbHlfbXVsIHIyLm51bSByMS5kZW4pO1xuICBkZW4gPSBwb2x5X211bCByMS5kZW4gcjIuZGVuO1xufVxuXG5sZXQgcmF0X25lZyByID0geyByIHdpdGggbnVtID0gcG9seV9uZWcgci5udW0gfVxubGV0IHJhdF9zdWIgcjEgcjIgPSByYXRfYWRkIHIxIChyYXRfbmVnIHIyKVxuXG5sZXQgcmF0X211bCByMSByMiA9IHtcbiAgbnVtID0gcG9seV9tdWwgcjEubnVtIHIyLm51bTtcbiAgZGVuID0gcG9seV9tdWwgcjEuZGVuIHIyLmRlbjtcbn1cblxubGV0IHJhdF9kaXYgcjEgcjIgPSB7XG4gIG51bSA9IHBvbHlfbXVsIHIxLm51bSByMi5kZW47XG4gIGRlbiA9IHBvbHlfbXVsIHIxLmRlbiByMi5udW07XG59XG5cbmxldCByYXRfdG9fZXhwciByID1cbiAgbGV0IG4gPSBwb2x5X3RvX2V4cHIgci5udW0gaW5cbiAgbGV0IGQgPSBwb2x5X3RvX2V4cHIgci5kZW4gaW5cbiAgbWF0Y2ggbiwgZCB3aXRoXG4gIHwgXywgTnVtIDEuMCAtPiBuXG4gIHwgTnVtIDAuMCwgXyAtPiB6ZXJvXG4gIHwgXyAtPiBEaXYgKG4sIGQpXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgQ09OVkVSVCBFWFBSIFRPIFJBVElPTkFMIChoYW5kbGVzIGRpdmlzaW9ucyBwcm9wZXJseSlcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG5sZXQgcmVjIGV4cHJfdG9fcmF0aW9uYWwgZSA6IHJhdGlvbmFsID1cbiAgbWF0Y2ggZSB3aXRoXG4gIHwgTnVtIG4gLT4gcmF0X3BvbHkgKGV4cHJfdG9fcG9seSAoTnVtIG4pKVxuICB8IFZhciBfIHwgRnVuYyBfIHwgU2luIF8gfCBDb3MgXyB8IEV4cCBfIHwgTG9nIF8gfCBTcXJ0IF8gLT4gXG4gICAgICByYXRfcG9seSAoZXhwcl90b19wb2x5IGUpXG4gIFxuICB8IE5lZyBlMSAtPiByYXRfbmVnIChleHByX3RvX3JhdGlvbmFsIGUxKVxuICB8IEFkZCAoYSwgYikgLT4gcmF0X2FkZCAoZXhwcl90b19yYXRpb25hbCBhKSAoZXhwcl90b19yYXRpb25hbCBiKVxuICB8IFN1YiAoYSwgYikgLT4gcmF0X3N1YiAoZXhwcl90b19yYXRpb25hbCBhKSAoZXhwcl90b19yYXRpb25hbCBiKVxuICB8IE11bCAoYSwgYikgLT4gcmF0X211bCAoZXhwcl90b19yYXRpb25hbCBhKSAoZXhwcl90b19yYXRpb25hbCBiKVxuICB8IERpdiAoYSwgYikgLT4gcmF0X2RpdiAoZXhwcl90b19yYXRpb25hbCBhKSAoZXhwcl90b19yYXRpb25hbCBiKVxuICBcbiAgfCBQb3cgKGJhc2UsIE51bSBuKSB3aGVuIG4gPj0gMS4wICYmIG4gPSBmbG9vciBuIC0+XG4gICAgICBsZXQgcmIgPSBleHByX3RvX3JhdGlvbmFsIGJhc2UgaW5cbiAgICAgIGxldCByZWMgcG93X24gciBrID0gaWYgayA9IDEgdGhlbiByIGVsc2UgcmF0X211bCByIChwb3dfbiByIChrLTEpKSBpblxuICAgICAgcG93X24gcmIgKGludF9vZl9mbG9hdCBuKVxuICB8IFBvdyAoYmFzZSwgTnVtIG4pIHdoZW4gbiA8PSAtMS4wICYmIG4gPSBmbG9vciBuIC0+XG4gICAgICBsZXQgcmIgPSBleHByX3RvX3JhdGlvbmFsIGJhc2UgaW5cbiAgICAgIGxldCByZWMgcG93X24gciBrID0gaWYgayA9IDEgdGhlbiByIGVsc2UgcmF0X211bCByIChwb3dfbiByIChrLTEpKSBpblxuICAgICAgbGV0IHBvc19wb3cgPSBwb3dfbiByYiAoaW50X29mX2Zsb2F0ICgtLiBuKSkgaW5cbiAgICAgIHsgbnVtID0gcG9zX3Bvdy5kZW47IGRlbiA9IHBvc19wb3cubnVtIH1cbiAgfCBQb3cgXyAtPiByYXRfcG9seSBbbW9ub19mcm9tX2F0b20gZV1cbiAgXG4gIHwgRGVsdGEgKGEsIGIpIC0+IGlmIGEgPSBiIHRoZW4gcmF0X29uZSBlbHNlIHJhdF96ZXJvXG4gIHwgUGFydGlhbCBfIC0+IHJhdF9wb2x5IFttb25vX2Zyb21fYXRvbSBlXVxuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIFNJTVBMSUZJQ0FUSU9OIEJZIFJBVElPTkFMIENBTk9OSUNBTElaQVRJT05cbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG5sZXQgc2ltcGxpZnlfdmlhX3JhdGlvbmFsIGUgPVxuICBsZXQgciA9IGV4cHJfdG9fcmF0aW9uYWwgZSBpblxuICByYXRfdG9fZXhwciByXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgU1RSVUNUVVJBTCBTSU1QTElGSUNBVElPTiAoZm9yIGNsZWFudXApXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxubGV0IHJlYyBzaW1wbGlmeV9zdHJ1Y3R1cmFsIGUgPVxuICBtYXRjaCBlIHdpdGhcbiAgfCBOdW0gXyB8IFZhciBfIHwgRGVsdGEgXyAtPiBlXG4gIHwgRnVuYyAobmFtZSwgYXJnKSAtPiBGdW5jIChuYW1lLCBzaW1wbGlmeV9zdHJ1Y3R1cmFsIGFyZylcbiAgXG4gIHwgTmVnIChOZWcgZTEpIC0+IHNpbXBsaWZ5X3N0cnVjdHVyYWwgZTFcbiAgfCBOZWcgKE51bSBuKSAtPiBOdW0gKC0uIG4pXG4gIHwgTmVnIGUxIC0+IE5lZyAoc2ltcGxpZnlfc3RydWN0dXJhbCBlMSlcbiAgXG4gIHwgQWRkIChOdW0gMC4wLCBlMSkgfCBBZGQgKGUxLCBOdW0gMC4wKSAtPiBzaW1wbGlmeV9zdHJ1Y3R1cmFsIGUxXG4gIHwgQWRkIChOdW0gYSwgTnVtIGIpIC0+IE51bSAoYSArLiBiKVxuICB8IEFkZCAoZTEsIE5lZyBlMikgd2hlbiBleHByX2VxdWFsIGUxIGUyIC0+IHplcm9cbiAgfCBBZGQgKE5lZyBlMSwgZTIpIHdoZW4gZXhwcl9lcXVhbCBlMSBlMiAtPiB6ZXJvXG4gIHwgQWRkIChhLCBiKSAtPiBBZGQgKHNpbXBsaWZ5X3N0cnVjdHVyYWwgYSwgc2ltcGxpZnlfc3RydWN0dXJhbCBiKVxuICBcbiAgfCBTdWIgKE51bSBhLCBOdW0gYikgLT4gTnVtIChhIC0uIGIpXG4gIHwgU3ViIChlMSwgTnVtIDAuMCkgLT4gc2ltcGxpZnlfc3RydWN0dXJhbCBlMVxuICB8IFN1YiAoTnVtIDAuMCwgZTEpIC0+IE5lZyAoc2ltcGxpZnlfc3RydWN0dXJhbCBlMSlcbiAgfCBTdWIgKGUxLCBlMikgd2hlbiBleHByX2VxdWFsIGUxIGUyIC0+IHplcm9cbiAgfCBTdWIgKEFkZCAoYSwgYiksIGMpIHdoZW4gZXhwcl9lcXVhbCBhIGMgLT4gc2ltcGxpZnlfc3RydWN0dXJhbCBiXG4gIHwgU3ViIChBZGQgKGEsIGIpLCBjKSB3aGVuIGV4cHJfZXF1YWwgYiBjIC0+IHNpbXBsaWZ5X3N0cnVjdHVyYWwgYVxuICB8IFN1YiAoYSwgYikgLT4gU3ViIChzaW1wbGlmeV9zdHJ1Y3R1cmFsIGEsIHNpbXBsaWZ5X3N0cnVjdHVyYWwgYilcbiAgXG4gIHwgTXVsIChOdW0gMC4wLCBfKSB8IE11bCAoXywgTnVtIDAuMCkgLT4gemVyb1xuICB8IE11bCAoTnVtIDEuMCwgZTEpIHwgTXVsIChlMSwgTnVtIDEuMCkgLT4gc2ltcGxpZnlfc3RydWN0dXJhbCBlMVxuICB8IE11bCAoTnVtICgtMS4wKSwgZTEpIC0+IE5lZyAoc2ltcGxpZnlfc3RydWN0dXJhbCBlMSlcbiAgfCBNdWwgKE51bSBhLCBOdW0gYikgLT4gTnVtIChhICouIGIpXG4gIHwgTXVsIChhLCBiKSAtPiBNdWwgKHNpbXBsaWZ5X3N0cnVjdHVyYWwgYSwgc2ltcGxpZnlfc3RydWN0dXJhbCBiKVxuICBcbiAgfCBEaXYgKE51bSAwLjAsIF8pIC0+IHplcm9cbiAgfCBEaXYgKGUxLCBOdW0gMS4wKSAtPiBzaW1wbGlmeV9zdHJ1Y3R1cmFsIGUxXG4gIHwgRGl2IChOdW0gYSwgTnVtIGIpIHdoZW4gYiA8PiAwLjAgLT4gTnVtIChhIC8uIGIpXG4gIHwgRGl2IChlMSwgZTIpIHdoZW4gZXhwcl9lcXVhbCBlMSBlMiAtPiBvbmVcbiAgfCBEaXYgKGEsIGIpIC0+IERpdiAoc2ltcGxpZnlfc3RydWN0dXJhbCBhLCBzaW1wbGlmeV9zdHJ1Y3R1cmFsIGIpXG4gIFxuICB8IFBvdyAoXywgTnVtIDAuMCkgLT4gb25lXG4gIHwgUG93IChlMSwgTnVtIDEuMCkgLT4gc2ltcGxpZnlfc3RydWN0dXJhbCBlMVxuICB8IFBvdyAoTnVtIDEuMCwgXykgLT4gb25lXG4gIHwgUG93IChOdW0gYSwgTnVtIGIpIC0+IE51bSAoYSAqKiBiKVxuICB8IFBvdyAoYSwgYikgLT4gUG93IChzaW1wbGlmeV9zdHJ1Y3R1cmFsIGEsIHNpbXBsaWZ5X3N0cnVjdHVyYWwgYilcbiAgXG4gIHwgRXhwIChOdW0gMC4wKSAtPiBvbmVcbiAgfCBFeHAgZTEgLT4gRXhwIChzaW1wbGlmeV9zdHJ1Y3R1cmFsIGUxKVxuICB8IExvZyAoTnVtIDEuMCkgLT4gemVyb1xuICB8IExvZyBlMSAtPiBMb2cgKHNpbXBsaWZ5X3N0cnVjdHVyYWwgZTEpXG4gIHwgU2luIChOdW0gMC4wKSAtPiB6ZXJvXG4gIHwgU2luIGUxIC0+IFNpbiAoc2ltcGxpZnlfc3RydWN0dXJhbCBlMSlcbiAgfCBDb3MgKE51bSAwLjApIC0+IG9uZVxuICB8IENvcyBlMSAtPiBDb3MgKHNpbXBsaWZ5X3N0cnVjdHVyYWwgZTEpXG4gIHwgU3FydCAoTnVtIG4pIHdoZW4gbiA+PSAwLjAgLT4gTnVtIChzcXJ0IG4pXG4gIHwgU3FydCBlMSAtPiBTcXJ0IChzaW1wbGlmeV9zdHJ1Y3R1cmFsIGUxKVxuICBcbiAgfCBQYXJ0aWFsIChlMSwgYykgLT5cbiAgICAgIGxldCBzID0gc2ltcGxpZnlfc3RydWN0dXJhbCBlMSBpblxuICAgICAgaWYgZGVwZW5kc19vbiBjIHMgdGhlbiBzaW1wbGlmeV9zdHJ1Y3R1cmFsIChkaWZmZXJlbnRpYXRlIGMgcykgZWxzZSB6ZXJvXG5cbmxldCByZWMgaXRlcmF0ZV9zdHJ1Y3R1cmFsIGUgPVxuICBsZXQgcyA9IHNpbXBsaWZ5X3N0cnVjdHVyYWwgZSBpblxuICBpZiBleHByX2VxdWFsIHMgZSB0aGVuIHMgZWxzZSBpdGVyYXRlX3N0cnVjdHVyYWwgc1xuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIE5VTUVSSUNBTCBaRVJPIERFVEVDVElPTlxuICAgXG4gICBJZiBleHByZXNzaW9uIGV2YWx1YXRlcyB0byAwIGF0IG11bHRpcGxlIHRlc3QgcG9pbnRzLCBsaWtlbHkgaWRlbnRpY2FsbHkgMC5cbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG5sZXQgdGVzdF9wb2ludHMgPSBbXG4gIFsoXCJyXCIsIDIuMCk7IChcIs64XCIsIDEuMCk7IChcIs+GXCIsIDAuNSldO1xuICBbKFwiclwiLCAzLjApOyAoXCLOuFwiLCAwLjcpOyAoXCLPhlwiLCAxLjApXTtcbiAgWyhcInJcIiwgMS41KTsgKFwizrhcIiwgMS41KTsgKFwiz4ZcIiwgMC4yKV07XG4gIFsoXCJyXCIsIDUuMCk7IChcIs64XCIsIDAuNSk7IChcIs+GXCIsIDIuMCldO1xuXVxuXG5sZXQgcmVjIGV2YWxfYXRfcG9pbnQgZSBiaW5kaW5ncyA9XG4gIG1hdGNoIGUgd2l0aFxuICB8IE51bSBuIC0+IG5cbiAgfCBWYXIgbmFtZSAtPiAodHJ5IExpc3QuYXNzb2MgbmFtZSBiaW5kaW5ncyB3aXRoIE5vdF9mb3VuZCAtPiBuYW4pXG4gIHwgRnVuYyAoXCJiXCIsIF8pIC0+IDEuMCAgKCogQ29uc3RhbnQgc2hhcGUgZnVuY3Rpb24gKilcbiAgfCBGdW5jIChcImInXCIsIF8pIC0+IDAuMFxuICB8IEZ1bmMgKFwizqZcIiwgXykgLT4gMC4wXG4gIHwgRnVuYyAoXCLOpidcIiwgXykgLT4gMC4wXG4gIHwgRnVuYyBfIC0+IG5hblxuICB8IE5lZyBlMSAtPiAtLiAoZXZhbF9hdF9wb2ludCBlMSBiaW5kaW5ncylcbiAgfCBBZGQgKGEsIGIpIC0+IGV2YWxfYXRfcG9pbnQgYSBiaW5kaW5ncyArLiBldmFsX2F0X3BvaW50IGIgYmluZGluZ3NcbiAgfCBTdWIgKGEsIGIpIC0+IGV2YWxfYXRfcG9pbnQgYSBiaW5kaW5ncyAtLiBldmFsX2F0X3BvaW50IGIgYmluZGluZ3NcbiAgfCBNdWwgKGEsIGIpIC0+IGV2YWxfYXRfcG9pbnQgYSBiaW5kaW5ncyAqLiBldmFsX2F0X3BvaW50IGIgYmluZGluZ3NcbiAgfCBEaXYgKGEsIGIpIC0+IFxuICAgICAgbGV0IGQgPSBldmFsX2F0X3BvaW50IGIgYmluZGluZ3MgaW5cbiAgICAgIGlmIGFic19mbG9hdCBkIDwgMWUtMTUgdGhlbiBuYW4gZWxzZSBldmFsX2F0X3BvaW50IGEgYmluZGluZ3MgLy4gZFxuICB8IFBvdyAoYSwgYikgLT4gKGV2YWxfYXRfcG9pbnQgYSBiaW5kaW5ncykgKiogKGV2YWxfYXRfcG9pbnQgYiBiaW5kaW5ncylcbiAgfCBFeHAgZTEgLT4gZXhwIChldmFsX2F0X3BvaW50IGUxIGJpbmRpbmdzKVxuICB8IExvZyBlMSAtPiBsb2cgKGV2YWxfYXRfcG9pbnQgZTEgYmluZGluZ3MpXG4gIHwgU2luIGUxIC0+IHNpbiAoZXZhbF9hdF9wb2ludCBlMSBiaW5kaW5ncylcbiAgfCBDb3MgZTEgLT4gY29zIChldmFsX2F0X3BvaW50IGUxIGJpbmRpbmdzKVxuICB8IFNxcnQgZTEgLT4gc3FydCAoZXZhbF9hdF9wb2ludCBlMSBiaW5kaW5ncylcbiAgfCBEZWx0YSAoYSwgYikgLT4gaWYgYSA9IGIgdGhlbiAxLjAgZWxzZSAwLjBcbiAgfCBQYXJ0aWFsIF8gLT4gbmFuXG5cbmxldCBsaWtlbHlfemVybyBlID1cbiAgTGlzdC5mb3JfYWxsIChmdW4gYmluZGluZ3MgLT5cbiAgICBsZXQgdiA9IGV2YWxfYXRfcG9pbnQgZSBiaW5kaW5ncyBpblxuICAgIEZsb2F0LmlzX25hbiB2IHx8IGFic19mbG9hdCB2IDwgMWUtMTBcbiAgKSB0ZXN0X3BvaW50c1xuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIENPTVBMRVRFIFNJTVBMSUZJQ0FUSU9OIFBJUEVMSU5FXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxubGV0IHNpbXBsaWZ5X2NvbXBsZXRlIGUgPVxuICAoKiAxLiBTdHJ1Y3R1cmFsIHNpbXBsaWZpY2F0aW9uICopXG4gIGxldCBlMSA9IGl0ZXJhdGVfc3RydWN0dXJhbCBlIGluXG4gICgqIDIuIFJhdGlvbmFsIGNhbm9uaWNhbGl6YXRpb24gKikgIFxuICBsZXQgZTIgPSBzaW1wbGlmeV92aWFfcmF0aW9uYWwgZTEgaW5cbiAgKCogMy4gRmluYWwgc3RydWN0dXJhbCBjbGVhbnVwICopXG4gIGxldCBlMyA9IGl0ZXJhdGVfc3RydWN0dXJhbCBlMiBpblxuICAoKiA0LiBOdW1lcmljYWwgemVybyBkZXRlY3Rpb24gKilcbiAgaWYgbGlrZWx5X3plcm8gZTMgdGhlbiB6ZXJvIGVsc2UgZTNcblxuKCogRm9yIGNvbXBhdGliaWxpdHkgKilcbmxldCBmdWxsX3NpbXBsaWZ5X3YyID0gc2ltcGxpZnlfY29tcGxldGVcbmxldCBkZWVwX3NpbXBsaWZ5ID0gc2ltcGxpZnlfc3RydWN0dXJhbFxuIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
