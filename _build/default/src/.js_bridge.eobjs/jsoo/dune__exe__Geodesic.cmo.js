// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cmo, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Dune__exe__Geodesic
//# unitInfo: Requires: Dune__exe__Numeric, Stdlib, Stdlib__Array, Stdlib__Float, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dune_exe_Numeric = global_data.Dune__exe__Numeric,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Float = global_data.Stdlib__Float,
    Stdlib = global_data.Stdlib,
    cst_Cannot_normalize_spacelike = "Cannot normalize: spacelike trajectory";
   function state_to_array(s){
    return [254, s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8]];
   }
   function array_to_state(a){
    var
     _q_ = caml_check_bound(a, 7)[8],
     _r_ = caml_check_bound(a, 6)[7],
     _s_ = caml_check_bound(a, 5)[6],
     _t_ = caml_check_bound(a, 4)[5],
     _u_ = caml_check_bound(a, 3)[4],
     _v_ = caml_check_bound(a, 2)[3],
     _w_ = caml_check_bound(a, 1)[2];
    return [254, caml_check_bound(a, 0)[1], _w_, _v_, _u_, _t_, _s_, _r_, _q_];
   }
   function geodesic_rhs(params, state){
    var
     r = state[2],
     theta = state[3],
     ut = state[5],
     ur = state[6],
     uth = state[7],
     uph = state[8],
     match = caml_call3(Dune_exe_Numeric[18], params, r, theta),
     g_ph_thph = match[7],
     g_ph_rph = match[6],
     g_th_phph = match[5],
     g_th_rth = match[4],
     g_r_phph = match[3],
     g_r_thth = match[2],
     g_r_rr = match[1],
     dur = - g_r_rr * ur * ur - g_r_thth * uth * uth - g_r_phph * uph * uph,
     duth = -2. * g_th_rth * ur * uth - g_th_phph * uph * uph,
     duph = -2. * g_ph_rph * ur * uph - 2. * g_ph_thph * uth * uph;
    return [254, ut, ur, uth, uph, 0., dur, duth, duph];
   }
   function add_state(s1, s2){
    return [254,
            s1[1] + s2[1],
            s1[2] + s2[2],
            s1[3] + s2[3],
            s1[4] + s2[4],
            s1[5] + s2[5],
            s1[6] + s2[6],
            s1[7] + s2[7],
            s1[8] + s2[8]];
   }
   function scale_state(c, s){
    return [254,
            c * s[1],
            c * s[2],
            c * s[3],
            c * s[4],
            c * s[5],
            c * s[6],
            c * s[7],
            c * s[8]];
   }
   function rk4_step(params, dt, state){
    var
     k1 = geodesic_rhs(params, state),
     k2 = geodesic_rhs(params, add_state(state, scale_state(dt / 2., k1))),
     k3 = geodesic_rhs(params, add_state(state, scale_state(dt / 2., k2))),
     k4 = geodesic_rhs(params, add_state(state, scale_state(dt, k3))),
     _n_ = scale_state(0.16666666666666666, k4),
     _o_ = add_state(scale_state(0.3333333333333333, k3), _n_),
     _p_ = add_state(scale_state(0.3333333333333333, k2), _o_),
     weighted = add_state(scale_state(0.16666666666666666, k1), _p_);
    return add_state(state, scale_state(dt, weighted));
   }
   function integrate_geodesic(params, dt, n_steps, initial){
    var match = params[1];
    if(0 === match[0])
     var b = match[1], b0 = b;
    else
     var b$0 = match[1], b0 = b$0;
    var
     trajectory = runtime.caml_make_vect(n_steps + 1 | 0, initial),
     current = [0, initial],
     _f_ = 1;
    if(n_steps >= 1){
     var i = _f_;
     for(;;){
      if(b0 * 1.001 < current[1][2]){
       current[1] = rk4_step(params, dt, current[1]);
       if(current[1][3] < 0.){
        var init = current[1];
        current[1] =
         [254,
          init[1],
          init[2],
          - current[1][3],
          init[4],
          init[5],
          init[6],
          init[7],
          - current[1][8]];
       }
       if(Stdlib_Float[11] < current[1][3]){
        var init$0 = current[1];
        current[1] =
         [254,
          init$0[1],
          init$0[2],
          2. * Stdlib_Float[11] - current[1][3],
          init$0[4],
          init$0[5],
          init$0[6],
          init$0[7],
          init$0[8]];
       }
       var
        phi = current[1][4] % (2. * Stdlib_Float[11]),
        init$1 = current[1],
        _g_ = init$1[8],
        _h_ = init$1[7],
        _i_ = init$1[6],
        _j_ = init$1[5],
        _k_ = phi < 0. ? phi + 2. * Stdlib_Float[11] : phi;
       current[1] =
        [254, init$1[1], init$1[2], init$1[3], _k_, _j_, _i_, _h_, _g_];
      }
      var _l_ = current[1];
      caml_check_bound(trajectory, i)[1 + i] = _l_;
      var _m_ = i + 1 | 0;
      if(n_steps === i) break;
      i = _m_;
     }
    }
    return trajectory;
   }
   function normalize_timelike(params, state){
    var
     r = state[2],
     theta = state[3],
     b = caml_call2(Dune_exe_Numeric[7], params, r),
     g_rr = r / (r - b),
     g_thth = r * r,
     g_phph = r * r * Math.pow(Math.sin(theta), 2.),
     spatial =
       g_rr * state[6] * state[6] + g_thth * state[7] * state[7]
       + g_phph * state[8] * state[8],
     ut_sq = 1. + spatial;
    return ut_sq < 0.
            ? caml_call1(Stdlib[2], cst_Cannot_normalize_spacelike)
            : [254,
              state[1],
              state[2],
              state[3],
              state[4],
              Math.sqrt(ut_sq),
              state[6],
              state[7],
              state[8]];
   }
   function radial_infall(params, r0, ur0){
    var state = [254, 0., r0, Stdlib_Float[11] / 2., 0., 0., ur0, 0., 0.];
    return normalize_timelike(params, state);
   }
   function circular_orbit(params, r0){
    caml_call2(Dune_exe_Numeric[7], params, r0);
    caml_call2(Dune_exe_Numeric[8], params, r0);
    var
     theta = Stdlib_Float[11] / 2.,
     uph = 0.5 / r0,
     state = [254, 0., r0, theta, 0., 0., 0., 0., uph];
    return normalize_timelike(params, state);
   }
   function normalize_null(params, state){
    var
     r = state[2],
     theta = state[3],
     b = caml_call2(Dune_exe_Numeric[7], params, r),
     g_rr = r / (r - b),
     g_thth = r * r,
     g_phph = r * r * Math.pow(Math.sin(theta), 2.),
     spatial =
       g_rr * state[6] * state[6] + g_thth * state[7] * state[7]
       + g_phph * state[8] * state[8];
    return [254,
            state[1],
            state[2],
            state[3],
            state[4],
            Math.sqrt(spatial),
            state[6],
            state[7],
            state[8]];
   }
   function radial_light(params, r0, outgoing){
    var
     theta = Stdlib_Float[11] / 2.,
     b = caml_call2(Dune_exe_Numeric[7], params, r0),
     kr = outgoing ? 1. : -1.,
     kt = Math.sqrt(r0 / (r0 - b)) * Math.abs(kr);
    return [254, 0., r0, theta, 0., kt, kr, 0., 0.];
   }
   function light_with_impact(params, r0, impact_param){
    var theta = Stdlib_Float[11] / 2.;
    caml_call2(Dune_exe_Numeric[7], params, r0);
    var
     kph = impact_param / (r0 * r0),
     state = [254, 0., r0, theta, 0., 0., -1., 0., kph];
    return normalize_null(params, state);
   }
   function find_turning_points(trajectory){
    var n = trajectory.length - 1, points = [0, 0], _c_ = n - 1 | 0, _b_ = 1;
    if(_c_ >= 1){
     var i = _b_;
     for(;;){
      var
       _d_ = i - 1 | 0,
       prev = caml_check_bound(trajectory, _d_)[1 + _d_],
       curr = caml_check_bound(trajectory, i)[1 + i];
      if(prev[6] * curr[6] < 0.) points[1] = [0, curr[2], points[1]];
      var _e_ = i + 1 | 0;
      if(_c_ === i) break;
      i = _e_;
     }
    }
    return caml_call1(Stdlib_List[10], points[1]);
   }
   function passes_through_wormhole(params, trajectory){
    var match = params[1];
    if(0 === match[0])
     var b = match[1], b0 = b;
    else
     var b$0 = match[1], b0 = b$0;
    return caml_call2
            (Stdlib_Array[24],
             function(s){return s[2] < b0 * 1.1 ? 1 : 0;},
             trajectory);
   }
   function proper_time_elapsed(trajectory){
    if(2 > trajectory.length - 1) return 0.;
    var
     _a_ = trajectory.length - 2 | 0,
     last = caml_check_bound(trajectory, _a_)[1 + _a_],
     first = caml_check_bound(trajectory, 0)[1];
    return last[1] - first[1];
   }
   function trajectory_to_xyz(trajectory){
    return caml_call2
            (Stdlib_Array[14],
             function(s){
              var
               x = s[2] * Math.sin(s[3]) * Math.cos(s[4]),
               y = s[2] * Math.sin(s[3]) * Math.sin(s[4]),
               z = s[2] * Math.cos(s[3]);
              return [0, x, y, z];
             },
             trajectory);
   }
   function trajectory_to_embedding(params, trajectory){
    return caml_call2
            (Stdlib_Array[14],
             function(s){
              var z = caml_call2(Dune_exe_Numeric[19], params, s[2]);
              return [0, s[2], z];
             },
             trajectory);
   }
   var
    Dune_exe_Geodesic =
      [0,
       state_to_array,
       array_to_state,
       geodesic_rhs,
       add_state,
       scale_state,
       rk4_step,
       integrate_geodesic,
       normalize_timelike,
       radial_infall,
       circular_orbit,
       normalize_null,
       radial_light,
       light_with_impact,
       find_turning_points,
       passes_through_wormhole,
       proper_time_elapsed,
       trajectory_to_xyz,
       trajectory_to_embedding];
   runtime.caml_register_global(59, Dune_exe_Geodesic, "Dune__exe__Geodesic");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLmpzX2JyaWRnZS5lb2Jqcy9qc29vL2R1bmVfX2V4ZV9fR2VvZGVzaWMuY21vLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Ii5qc19icmlkZ2UuZW9ianMvanNvby9kdW5lX19leGVfX0dlb2Rlc2ljLmNtby5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiRHVuZV9leGVfTnVtZXJpYyIsIlN0ZGxpYl9BcnJheSIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX0Zsb2F0IiwiU3RkbGliIiwiY3N0X0Nhbm5vdF9ub3JtYWxpemVfc3BhY2VsaWtlIiwic3RhdGVfdG9fYXJyYXkiLCJzIiwiYXJyYXlfdG9fc3RhdGUiLCJhIiwiZ2VvZGVzaWNfcmhzIiwicGFyYW1zIiwic3RhdGUiLCJyIiwidGhldGEiLCJ1dCIsInVyIiwidXRoIiwidXBoIiwibWF0Y2giLCJnX3BoX3RocGgiLCJnX3BoX3JwaCIsImdfdGhfcGhwaCIsImdfdGhfcnRoIiwiZ19yX3BocGgiLCJnX3JfdGh0aCIsImdfcl9yciIsImR1ciIsImR1dGgiLCJkdXBoIiwiYWRkX3N0YXRlIiwiczEiLCJzMiIsInNjYWxlX3N0YXRlIiwiYyIsInJrNF9zdGVwIiwiZHQiLCJrMSIsImsyIiwiazMiLCJrNCIsIndlaWdodGVkIiwiaW50ZWdyYXRlX2dlb2Rlc2ljIiwibl9zdGVwcyIsImluaXRpYWwiLCJiIiwiYjAiLCJ0cmFqZWN0b3J5IiwiY3VycmVudCIsImkiLCJpbml0IiwicGhpIiwibm9ybWFsaXplX3RpbWVsaWtlIiwiZ19yciIsImdfdGh0aCIsImdfcGhwaCIsInNwYXRpYWwiLCJ1dF9zcSIsInJhZGlhbF9pbmZhbGwiLCJyMCIsInVyMCIsImNpcmN1bGFyX29yYml0Iiwibm9ybWFsaXplX251bGwiLCJyYWRpYWxfbGlnaHQiLCJvdXRnb2luZyIsImtyIiwia3QiLCJsaWdodF93aXRoX2ltcGFjdCIsImltcGFjdF9wYXJhbSIsImtwaCIsImZpbmRfdHVybmluZ19wb2ludHMiLCJuIiwicG9pbnRzIiwicHJldiIsImN1cnIiLCJwYXNzZXNfdGhyb3VnaF93b3JtaG9sZSIsInByb3Blcl90aW1lX2VsYXBzZWQiLCJsYXN0IiwiZmlyc3QiLCJ0cmFqZWN0b3J5X3RvX3h5eiIsIngiLCJ5IiwieiIsInRyYWplY3RvcnlfdG9fZW1iZWRkaW5nIiwiRHVuZV9leGVfR2VvZGVzaWMiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ2VvZGVzaWMubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLFlBQUFDLGVBQUFDO0FBQUFBLElDd0JFO0FBQUEsR0FBd0Q7QUFBQSxZQUFBQyxlQUFBQztBQUFBQTtBQUFBQSxLQUFBLE1BSVg7QUFBQSxXQUFiO0FBQUEsV0FBYjtBQUFBLFdBQVo7QUFBQSxXQURzQztBQUFBLFdBQWI7QUFBQSxXQUFmO0FBQUEsSUFBWCwwRUFBSztBQUFBLEdBQ3lDO0FBQUEsWUFBQUMsYUFBQUMsUUFBQUM7QUFBQUE7QUFBQUEsS0FBQUMsSUFhcEQ7QUFB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QUFBQTtBQUFBQSxlQUFBeUUsSUFDVSxPQUFPLGlCQUFlO0FBQUEsZUFBQUMsSUFDdEIsT0FBTyxpQkFBZTtBQUFBLGVBQUFDLElBQ3RCLE9BQU87QUFBQSxjQUNmO0FBQUEsYUFBUztBQUFBLHdCQUNDO0FBQUE7QUFBQSxZQUFBQyx3QkFBQXhFLFFBQUFvQztBQUFBQSxJQUlaO0FBQUE7QUFBQSxzQkFBQXhDO0FBQUFBLGtCQUFBMkUsSUFDVTtBQUFBLGNBQ1I7QUFBQSxhQUFRO0FBQUEsd0JBQ0U7QUFBQTtBQUFBO0FBQUEsSUFBQUU7QUFBQUEsTURyUmQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIGdlb2Rlc2ljLm1sIC0gR2VvZGVzaWMgaW50ZWdyYXRpb24gdmlhIFJLNCAqKVxuXG5vcGVuIEV4cHIgW0BAd2FybmluZyBcIi0zM1wiXVxub3BlbiBOdW1lcmljXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgR0VPREVTSUMgU1RBVEVcbiAgIFxuICAgU3RhdGUgdmVjdG9yOiAodCwgciwgzrgsIM+GLCB1XnQsIHVeciwgdV7OuCwgdV7PhilcbiAgIHdoZXJlIHVezrwgPSBkeF7OvC9kz4QgKG9yIGR4Xs68L2TOuyBmb3IgbnVsbCBnZW9kZXNpY3MpXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxudHlwZSBnZW9kZXNpY19zdGF0ZSA9IHtcbiAgdCA6IGZsb2F0O1xuICByIDogZmxvYXQ7XG4gIHRoZXRhIDogZmxvYXQ7XG4gIHBoaSA6IGZsb2F0O1xuICB1dCA6IGZsb2F0OyAgICgqIGR0L2TPhCAqKVxuICB1ciA6IGZsb2F0OyAgICgqIGRyL2TPhCAqKVxuICB1dGggOiBmbG9hdDsgICgqIGTOuC9kz4QgKilcbiAgdXBoIDogZmxvYXQ7ICAoKiBkz4YvZM+EICopXG59XG5cbmxldCBzdGF0ZV90b19hcnJheSBzID1cbiAgW3wgcy50OyBzLnI7IHMudGhldGE7IHMucGhpOyBzLnV0OyBzLnVyOyBzLnV0aDsgcy51cGggfF1cblxubGV0IGFycmF5X3RvX3N0YXRlIGEgPVxuICB7IHQgPSBhLigwKTsgciA9IGEuKDEpOyB0aGV0YSA9IGEuKDIpOyBwaGkgPSBhLigzKTtcbiAgICB1dCA9IGEuKDQpOyB1ciA9IGEuKDUpOyB1dGggPSBhLig2KTsgdXBoID0gYS4oNykgfVxuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIEdFT0RFU0lDIEVRVUFUSU9OXG4gICBcbiAgIGTCsnhezrwvZM+EwrIgKyDOk17OvF/Osc6yIChkeF7OsS9kz4QpKGR4Xs6yL2TPhCkgPSAwXG4gICBcbiAgIE9yIGFzIGZpcnN0LW9yZGVyIHN5c3RlbTpcbiAgIGR4Xs68L2TPhCA9IHVezrxcbiAgIGR1Xs68L2TPhCA9IC3Ok17OvF/Osc6yIHVezrEgdV7OslxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICopXG5cbmxldCBnZW9kZXNpY19yaHMgcGFyYW1zIHN0YXRlID1cbiAgbGV0IHIgPSBzdGF0ZS5yIGluXG4gIGxldCB0aGV0YSA9IHN0YXRlLnRoZXRhIGluXG4gIGxldCB1dCA9IHN0YXRlLnV0IGluXG4gIGxldCB1ciA9IHN0YXRlLnVyIGluXG4gIGxldCB1dGggPSBzdGF0ZS51dGggaW5cbiAgbGV0IHVwaCA9IHN0YXRlLnVwaCBpblxuICBcbiAgKCogR2V0IENocmlzdG9mZmVsIHN5bWJvbHMgKilcbiAgbGV0IChnX3JfcnIsIGdfcl90aHRoLCBnX3JfcGhwaCwgZ190aF9ydGgsIGdfdGhfcGhwaCwgZ19waF9ycGgsIGdfcGhfdGhwaCkgPVxuICAgIGdhbW1hX251bSBwYXJhbXMgfnIgfnRoZXRhIGluXG4gIFxuICAoKiBGb3IgzqYgPSAwOiDOk150X86xzrIgPSAwLCBzbyBkdV50L2TPhCA9IDAgKilcbiAgbGV0IGR1dCA9IDAuMCBpblxuICBcbiAgKCogZHVeci9kz4QgPSAtzpNecl/Osc6yIHVezrEgdV7OsiAqKVxuICBsZXQgZHVyID0gXG4gICAgLS4gZ19yX3JyICouIHVyICouIHVyXG4gICAgLS4gZ19yX3RodGggKi4gdXRoICouIHV0aFxuICAgIC0uIGdfcl9waHBoICouIHVwaCAqLiB1cGggaW5cbiAgXG4gICgqIGR1Xs64L2TPhCA9IC3Ok17OuF/Osc6yIHVezrEgdV7OsiAqKVxuICBsZXQgZHV0aCA9XG4gICAgLS4gMi4wICouIGdfdGhfcnRoICouIHVyICouIHV0aFxuICAgIC0uIGdfdGhfcGhwaCAqLiB1cGggKi4gdXBoIGluXG4gIFxuICAoKiBkdV7Phi9kz4QgPSAtzpNez4ZfzrHOsiB1Xs6xIHVezrIgKilcbiAgbGV0IGR1cGggPVxuICAgIC0uIDIuMCAqLiBnX3BoX3JwaCAqLiB1ciAqLiB1cGhcbiAgICAtLiAyLjAgKi4gZ19waF90aHBoICouIHV0aCAqLiB1cGggaW5cbiAgXG4gICgqIGR4Xs68L2TPhCA9IHVezrwgKilcbiAgeyB0ID0gdXQ7IHIgPSB1cjsgdGhldGEgPSB1dGg7IHBoaSA9IHVwaDtcbiAgICB1dCA9IGR1dDsgdXIgPSBkdXI7IHV0aCA9IGR1dGg7IHVwaCA9IGR1cGggfVxuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIFJLNCBJTlRFR1JBVE9SXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxubGV0IGFkZF9zdGF0ZSBzMSBzMiA9XG4gIHsgdCA9IHMxLnQgKy4gczIudDsgciA9IHMxLnIgKy4gczIucjsgXG4gICAgdGhldGEgPSBzMS50aGV0YSArLiBzMi50aGV0YTsgcGhpID0gczEucGhpICsuIHMyLnBoaTtcbiAgICB1dCA9IHMxLnV0ICsuIHMyLnV0OyB1ciA9IHMxLnVyICsuIHMyLnVyO1xuICAgIHV0aCA9IHMxLnV0aCArLiBzMi51dGg7IHVwaCA9IHMxLnVwaCArLiBzMi51cGggfVxuXG5sZXQgc2NhbGVfc3RhdGUgYyBzID1cbiAgeyB0ID0gYyAqLiBzLnQ7IHIgPSBjICouIHMucjsgXG4gICAgdGhldGEgPSBjICouIHMudGhldGE7IHBoaSA9IGMgKi4gcy5waGk7XG4gICAgdXQgPSBjICouIHMudXQ7IHVyID0gYyAqLiBzLnVyO1xuICAgIHV0aCA9IGMgKi4gcy51dGg7IHVwaCA9IGMgKi4gcy51cGggfVxuXG5sZXQgcms0X3N0ZXAgcGFyYW1zIGR0IHN0YXRlID1cbiAgbGV0IGsxID0gZ2VvZGVzaWNfcmhzIHBhcmFtcyBzdGF0ZSBpblxuICBsZXQgazIgPSBnZW9kZXNpY19yaHMgcGFyYW1zIChhZGRfc3RhdGUgc3RhdGUgKHNjYWxlX3N0YXRlIChkdCAvLiAyLjApIGsxKSkgaW5cbiAgbGV0IGszID0gZ2VvZGVzaWNfcmhzIHBhcmFtcyAoYWRkX3N0YXRlIHN0YXRlIChzY2FsZV9zdGF0ZSAoZHQgLy4gMi4wKSBrMikpIGluXG4gIGxldCBrNCA9IGdlb2Rlc2ljX3JocyBwYXJhbXMgKGFkZF9zdGF0ZSBzdGF0ZSAoc2NhbGVfc3RhdGUgZHQgazMpKSBpblxuICBcbiAgbGV0IHdlaWdodGVkID0gYWRkX3N0YXRlIChzY2FsZV9zdGF0ZSAoMS4wIC8uIDYuMCkgazEpXG4gICAgICAgICAgICAgICAgKGFkZF9zdGF0ZSAoc2NhbGVfc3RhdGUgKDIuMCAvLiA2LjApIGsyKVxuICAgICAgICAgICAgICAgIChhZGRfc3RhdGUgKHNjYWxlX3N0YXRlICgyLjAgLy4gNi4wKSBrMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChzY2FsZV9zdGF0ZSAoMS4wIC8uIDYuMCkgazQpKSkgaW5cbiAgXG4gIGFkZF9zdGF0ZSBzdGF0ZSAoc2NhbGVfc3RhdGUgZHQgd2VpZ2h0ZWQpXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgSU5URUdSQVRJT04gV0lUSCBCT1VOREFSWSBDSEVDS0lOR1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICopXG5cbmxldCBpbnRlZ3JhdGVfZ2VvZGVzaWMgcGFyYW1zIH5kdCB+bl9zdGVwcyBpbml0aWFsID1cbiAgbGV0IGIwID0gbWF0Y2ggcGFyYW1zLnNoYXBlIHdpdGggQ29uc3RhbnRCIGIgLT4gYiB8IEVsbGlzQiBiIC0+IGIgaW5cbiAgbGV0IHRyYWplY3RvcnkgPSBBcnJheS5tYWtlIChuX3N0ZXBzICsgMSkgaW5pdGlhbCBpblxuICBsZXQgY3VycmVudCA9IHJlZiBpbml0aWFsIGluXG4gIFxuICBmb3IgaSA9IDEgdG8gbl9zdGVwcyBkb1xuICAgICgqIENoZWNrIGlmIHdlJ3JlIHRvbyBjbG9zZSB0byB0aHJvYXQgKilcbiAgICBpZiAhY3VycmVudC5yID4gYjAgKi4gMS4wMDEgdGhlbiBiZWdpblxuICAgICAgY3VycmVudCA6PSByazRfc3RlcCBwYXJhbXMgZHQgIWN1cnJlbnQ7XG4gICAgICAoKiBLZWVwIM64IGluIFswLCDPgF0gKilcbiAgICAgIGlmICFjdXJyZW50LnRoZXRhIDwgMC4wIHRoZW5cbiAgICAgICAgY3VycmVudCA6PSB7ICFjdXJyZW50IHdpdGggdGhldGEgPSAtLiAhY3VycmVudC50aGV0YTsgdXBoID0gLS4gIWN1cnJlbnQudXBoIH07XG4gICAgICBpZiAhY3VycmVudC50aGV0YSA+IEZsb2F0LnBpIHRoZW5cbiAgICAgICAgY3VycmVudCA6PSB7ICFjdXJyZW50IHdpdGggdGhldGEgPSAyLjAgKi4gRmxvYXQucGkgLS4gIWN1cnJlbnQudGhldGEgfTtcbiAgICAgICgqIEtlZXAgz4YgaW4gWzAsIDLPgF0gKilcbiAgICAgIGxldCBwaGknID0gbW9kX2Zsb2F0ICFjdXJyZW50LnBoaSAoMi4wICouIEZsb2F0LnBpKSBpblxuICAgICAgY3VycmVudCA6PSB7ICFjdXJyZW50IHdpdGggcGhpID0gaWYgcGhpJyA8IDAuMCB0aGVuIHBoaScgKy4gMi4wICouIEZsb2F0LnBpIGVsc2UgcGhpJyB9XG4gICAgZW5kO1xuICAgIHRyYWplY3RvcnkuKGkpIDwtICFjdXJyZW50XG4gIGRvbmU7XG4gIFxuICB0cmFqZWN0b3J5XG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgSU5JVElBTCBDT05ESVRJT05TXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxuKCogTm9ybWFsaXplIDQtdmVsb2NpdHkgZm9yIHRpbWVsaWtlIGdlb2Rlc2ljOiBnX868zr0gdV7OvCB1Xs69ID0gLTEgKilcbmxldCBub3JtYWxpemVfdGltZWxpa2UgcGFyYW1zIHN0YXRlID1cbiAgbGV0IHIgPSBzdGF0ZS5yIGluXG4gIGxldCB0aGV0YSA9IHN0YXRlLnRoZXRhIGluXG4gIGxldCBiID0gZXZhbF9zaGFwZSBwYXJhbXMgciBpblxuICBcbiAgKCogZ190dCA9IC0xLCBnX3JyID0gci8oci1iKSwgZ1/OuM64ID0gcsKyLCBnX8+Gz4YgPSBywrJzaW7Css64ICopXG4gIGxldCBnX3JyID0gciAvLiAociAtLiBiKSBpblxuICBsZXQgZ190aHRoID0gciAqLiByIGluXG4gIGxldCBnX3BocGggPSByICouIHIgKi4gKHNpbiB0aGV0YSkgKiogMi4wIGluXG4gIFxuICAoKiAtMSA9IGdfdHQgKHVedCnCsiArIGdfcnIgKHVecinCsiArIGdfzrjOuCAodV7OuCnCsiArIGdfz4bPhiAodV7PhinCsiAqKVxuICAoKiAtMSA9IC0odV50KcKyICsgZ19yciAodV5yKcKyICsgZ1/OuM64ICh1Xs64KcKyICsgZ1/Phs+GICh1Xs+GKcKyICopXG4gIGxldCBzcGF0aWFsID0gZ19yciAqLiBzdGF0ZS51ciAqLiBzdGF0ZS51ciBcbiAgICAgICAgICAgICAgKy4gZ190aHRoICouIHN0YXRlLnV0aCAqLiBzdGF0ZS51dGggXG4gICAgICAgICAgICAgICsuIGdfcGhwaCAqLiBzdGF0ZS51cGggKi4gc3RhdGUudXBoIGluXG4gIGxldCB1dF9zcSA9IDEuMCArLiBzcGF0aWFsIGluXG4gIGlmIHV0X3NxIDwgMC4wIHRoZW4gZmFpbHdpdGggXCJDYW5ub3Qgbm9ybWFsaXplOiBzcGFjZWxpa2UgdHJhamVjdG9yeVwiXG4gIGVsc2UgeyBzdGF0ZSB3aXRoIHV0ID0gc3FydCB1dF9zcSB9XG5cbigqIENyZWF0ZSBpbml0aWFsIHN0YXRlIGZvciByYWRpYWwgaW5mYWxsICopXG5sZXQgcmFkaWFsX2luZmFsbCBwYXJhbXMgfnIwIH51cjAgPVxuICBsZXQgc3RhdGUgPSB7IHQgPSAwLjA7IHIgPSByMDsgdGhldGEgPSBGbG9hdC5waSAvLiAyLjA7IHBoaSA9IDAuMDtcbiAgICAgICAgICAgICAgICB1dCA9IDAuMDsgdXIgPSB1cjA7IHV0aCA9IDAuMDsgdXBoID0gMC4wIH0gaW5cbiAgbm9ybWFsaXplX3RpbWVsaWtlIHBhcmFtcyBzdGF0ZVxuXG4oKiBDcmVhdGUgaW5pdGlhbCBzdGF0ZSBmb3IgY2lyY3VsYXIgb3JiaXQgKGlmIGV4aXN0cykgKilcbmxldCBjaXJjdWxhcl9vcmJpdCBwYXJhbXMgfnIwID1cbiAgbGV0IGIgPSBldmFsX3NoYXBlIHBhcmFtcyByMCBpblxuICBsZXQgX2InID0gZXZhbF9zaGFwZV9kZXJpdiBwYXJhbXMgcjAgaW5cbiAgXG4gICgqIEZvciBjaXJjdWxhciBvcmJpdDogzpNecl90dCAodV50KcKyICsgzpNecl/Phs+GICh1Xs+GKcKyID0gMCAqKVxuICAoKiBXaXRoIM6mID0gMDogzpNecl90dCA9IDAsIHNvIHdlIG5lZWQgzpNecl/Phs+GID0gMCwgd2hpY2ggbWVhbnMgciA9IGIgKilcbiAgKCogTm8gc3RhYmxlIGNpcmN1bGFyIG9yYml0cyBpbiBzaW1wbGUgd29ybWhvbGUhICopXG4gIFxuICAoKiBJbnN0ZWFkLCBnaXZlIHRhbmdlbnRpYWwgdmVsb2NpdHkgKilcbiAgbGV0IHRoZXRhID0gRmxvYXQucGkgLy4gMi4wIGluXG4gIGxldCBfZ19waHBoID0gcjAgKi4gcjAgaW5cbiAgXG4gICgqIFBpY2sgdV7PhiBzdWNoIHRoYXQgb3JiaXQgaXMgYm91bmQgKilcbiAgbGV0IHVwaCA9IDAuNSAvLiByMCBpbiAgKCogQXJiaXRyYXJ5IGNob2ljZSAqKVxuICBcbiAgbGV0IHN0YXRlID0geyB0ID0gMC4wOyByID0gcjA7IHRoZXRhOyBwaGkgPSAwLjA7XG4gICAgICAgICAgICAgICAgdXQgPSAwLjA7IHVyID0gMC4wOyB1dGggPSAwLjA7IHVwaCB9IGluXG4gIG5vcm1hbGl6ZV90aW1lbGlrZSBwYXJhbXMgc3RhdGVcblxuKCogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICBOVUxMIEdFT0RFU0lDUyAoTElHSFQgUkFZUylcbiAgIFxuICAgRm9yIG51bGwgZ2VvZGVzaWNzOiBnX868zr0ga17OvCBrXs69ID0gMFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICopXG5cbigqIE5vcm1hbGl6ZSBmb3IgbnVsbCBnZW9kZXNpYzogZ1/OvM69IGtezrwga17OvSA9IDAgKilcbmxldCBub3JtYWxpemVfbnVsbCBwYXJhbXMgc3RhdGUgPVxuICBsZXQgciA9IHN0YXRlLnIgaW5cbiAgbGV0IHRoZXRhID0gc3RhdGUudGhldGEgaW5cbiAgbGV0IGIgPSBldmFsX3NoYXBlIHBhcmFtcyByIGluXG4gIFxuICBsZXQgZ19yciA9IHIgLy4gKHIgLS4gYikgaW5cbiAgbGV0IGdfdGh0aCA9IHIgKi4gciBpblxuICBsZXQgZ19waHBoID0gciAqLiByICouIChzaW4gdGhldGEpICoqIDIuMCBpblxuICBcbiAgKCogMCA9IC0oa150KcKyICsgZ19yciAoa15yKcKyICsgZ1/OuM64IChrXs64KcKyICsgZ1/Phs+GIChrXs+GKcKyICopXG4gIGxldCBzcGF0aWFsID0gZ19yciAqLiBzdGF0ZS51ciAqLiBzdGF0ZS51ciBcbiAgICAgICAgICAgICAgKy4gZ190aHRoICouIHN0YXRlLnV0aCAqLiBzdGF0ZS51dGggXG4gICAgICAgICAgICAgICsuIGdfcGhwaCAqLiBzdGF0ZS51cGggKi4gc3RhdGUudXBoIGluXG4gIHsgc3RhdGUgd2l0aCB1dCA9IHNxcnQgc3BhdGlhbCB9XG5cbigqIFJhZGlhbCBsaWdodCByYXkgKilcbmxldCByYWRpYWxfbGlnaHQgcGFyYW1zIH5yMCB+b3V0Z29pbmcgPVxuICBsZXQgdGhldGEgPSBGbG9hdC5waSAvLiAyLjAgaW5cbiAgbGV0IGIgPSBldmFsX3NoYXBlIHBhcmFtcyByMCBpblxuICBcbiAgKCogRm9yIHJhZGlhbCBudWxsIGdlb2Rlc2ljOiAtKGtedCnCsiArIGdfcnIgKGtecinCsiA9IDAgKilcbiAgKCoga150ID0g4oiaKGdfcnIpIHxrXnJ8ID0g4oiaKHIvKHItYikpIHxrXnJ8ICopXG4gIGxldCBrciA9IGlmIG91dGdvaW5nIHRoZW4gMS4wIGVsc2UgLTEuMCBpblxuICBsZXQga3QgPSBzcXJ0IChyMCAvLiAocjAgLS4gYikpICouIGFic19mbG9hdCBrciBpblxuICBcbiAgeyB0ID0gMC4wOyByID0gcjA7IHRoZXRhOyBwaGkgPSAwLjA7XG4gICAgdXQgPSBrdDsgdXIgPSBrcjsgdXRoID0gMC4wOyB1cGggPSAwLjAgfVxuXG4oKiBMaWdodCByYXkgd2l0aCBpbXBhY3QgcGFyYW1ldGVyICopXG5sZXQgbGlnaHRfd2l0aF9pbXBhY3QgcGFyYW1zIH5yMCB+aW1wYWN0X3BhcmFtID1cbiAgbGV0IHRoZXRhID0gRmxvYXQucGkgLy4gMi4wIGluXG4gIGxldCBiID0gZXZhbF9zaGFwZSBwYXJhbXMgcjAgaW5cbiAgXG4gICgqIEltcGFjdCBwYXJhbWV0ZXIgzr4gPSBML0UgPSBywrIgKGTPhi9kdCkgLyAoZHQvZM+EKSAqKVxuICAoKiBGb3IgZGlzdGFudCByYXk6IM6+IOKJiCByICogc2luKGFuZ2xlIGZyb20gcmFkaWFsKSAqKVxuICBsZXQga3BoID0gaW1wYWN0X3BhcmFtIC8uIChyMCAqLiByMCkgaW5cbiAgbGV0IGtyID0gLTEuMCBpbiAgKCogSW5nb2luZyAqKVxuICBcbiAgbGV0IHN0YXRlID0geyB0ID0gMC4wOyByID0gcjA7IHRoZXRhOyBwaGkgPSAwLjA7XG4gICAgICAgICAgICAgICAgdXQgPSAwLjA7IHVyID0ga3I7IHV0aCA9IDAuMDsgdXBoID0ga3BoIH0gaW5cbiAgbm9ybWFsaXplX251bGwgcGFyYW1zIHN0YXRlXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgVFJBSkVDVE9SWSBBTkFMWVNJU1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICopXG5cbigqIEZpbmQgdHVybmluZyBwb2ludHMgKHdoZXJlIHVyIGNoYW5nZXMgc2lnbikgKilcbmxldCBmaW5kX3R1cm5pbmdfcG9pbnRzIHRyYWplY3RvcnkgPVxuICBsZXQgbiA9IEFycmF5Lmxlbmd0aCB0cmFqZWN0b3J5IGluXG4gIGxldCBwb2ludHMgPSByZWYgW10gaW5cbiAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgbGV0IHByZXYgPSB0cmFqZWN0b3J5LihpLTEpIGluXG4gICAgbGV0IGN1cnIgPSB0cmFqZWN0b3J5LihpKSBpblxuICAgIGlmIHByZXYudXIgKi4gY3Vyci51ciA8IDAuMCB0aGVuXG4gICAgICBwb2ludHMgOj0gY3Vyci5yIDo6ICFwb2ludHNcbiAgZG9uZTtcbiAgTGlzdC5yZXYgIXBvaW50c1xuXG4oKiBDaGVjayBpZiB0cmFqZWN0b3J5IHBhc3NlcyB0aHJvdWdoIHdvcm1ob2xlICopXG5sZXQgcGFzc2VzX3Rocm91Z2hfd29ybWhvbGUgcGFyYW1zIHRyYWplY3RvcnkgPVxuICBsZXQgYjAgPSBtYXRjaCBwYXJhbXMuc2hhcGUgd2l0aCBDb25zdGFudEIgYiAtPiBiIHwgRWxsaXNCIGIgLT4gYiBpblxuICBBcnJheS5leGlzdHMgKGZ1biBzIC0+IHMuciA8IGIwICouIDEuMSkgdHJhamVjdG9yeVxuXG4oKiBDb21wdXRlIHByb3BlciB0aW1lIGVsYXBzZWQgKilcbmxldCBwcm9wZXJfdGltZV9lbGFwc2VkIHRyYWplY3RvcnkgPVxuICBpZiBBcnJheS5sZW5ndGggdHJhamVjdG9yeSA8IDIgdGhlbiAwLjBcbiAgZWxzZVxuICAgIGxldCBsYXN0ID0gdHJhamVjdG9yeS4oQXJyYXkubGVuZ3RoIHRyYWplY3RvcnkgLSAxKSBpblxuICAgIGxldCBmaXJzdCA9IHRyYWplY3RvcnkuKDApIGluXG4gICAgbGFzdC50IC0uIGZpcnN0LnQgICgqIEZvciDOpj0wLCBjb29yZGluYXRlIHRpbWUg4omIIHByb3BlciB0aW1lIGF0IGluZmluaXR5ICopXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgT1VUUFVUIEZPUiBWSVNVQUxJWkFUSU9OXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxuKCogQ29udmVydCB0cmFqZWN0b3J5IHRvICh4LCB5LCB6KSBmb3IgM0QgcGxvdHRpbmcgKilcbmxldCB0cmFqZWN0b3J5X3RvX3h5eiB0cmFqZWN0b3J5ID1cbiAgQXJyYXkubWFwIChmdW4gcyAtPlxuICAgIGxldCB4ID0gcy5yICouIHNpbiBzLnRoZXRhICouIGNvcyBzLnBoaSBpblxuICAgIGxldCB5ID0gcy5yICouIHNpbiBzLnRoZXRhICouIHNpbiBzLnBoaSBpblxuICAgIGxldCB6ID0gcy5yICouIGNvcyBzLnRoZXRhIGluXG4gICAgKHgsIHksIHopXG4gICkgdHJhamVjdG9yeVxuXG4oKiBDb252ZXJ0IHRvIChyLCB6X2VtYmVkZGluZykgZm9yIDJEIGVtYmVkZGluZyBkaWFncmFtICopXG5sZXQgdHJhamVjdG9yeV90b19lbWJlZGRpbmcgcGFyYW1zIHRyYWplY3RvcnkgPVxuICBBcnJheS5tYXAgKGZ1biBzIC0+XG4gICAgbGV0IHogPSBlbWJlZGRpbmdfeiBwYXJhbXMgcy5yIGluXG4gICAgKHMuciwgeilcbiAgKSB0cmFqZWN0b3J5XG4iXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
