// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cmo, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Dune__exe__Numeric
//# unitInfo: Requires: Dune__exe__Christoffel, Dune__exe__Metric, Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\xcf\x86",
    cst$0 = "\xce\xb8",
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Dune_exe_Metric = global_data.Dune__exe__Metric,
    Dune_exe_Christoffel = global_data.Dune__exe__Christoffel,
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, [0, "t", 0.], 0],
    cst_r = "r",
    cst_b = "b\xe2\x82\x80",
    _b_ = [0, [11, "Unbound variable: ", [2, 0, 0]], "Unbound variable: %s"],
    _c_ = [0, [11, "Unknown function: ", [2, 0, 0]], "Unknown function: %s"],
    cst_Cannot_numerically_evaluat =
      "Cannot numerically evaluate unevaluated Partial";
   function bind(name, value, env){return [0, [0, name, value], env];}
   function lookup(name, env){
    try{var _n_ = [0, caml_call2(Stdlib_List[49], name, env)]; return _n_;}
    catch(_o_){
     var _m_ = caml_wrap_exception(_o_);
     if(_m_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_m_, 0);
    }
   }
   function wormhole_env(b0, r, theta, phi){
    return [0,
            [0, cst_b, b0],
            [0,
             [0, cst_r, r],
             [0, [0, cst$0, theta], [0, [0, cst, phi], _a_]]]];
   }
   function default_wormhole(b0){return [0, [0, b0], 0];}
   function ellis_wormhole(b0){return [0, [1, b0], 0];}
   function eval_shape(params, r){
    var match = params[1];
    if(0 === match[0]){var b0 = match[1]; return b0;}
    var b0$0 = match[1];
    return b0$0 * b0$0 / r;
   }
   function eval_shape_deriv(params, r){
    var match = params[1];
    if(0 === match[0]) return 0.;
    var b0 = match[1];
    return - b0 * b0 / (r * r);
   }
   function eval_redshift(params, r){
    var match = params[2];
    if(! match) return 0.;
    var phi0 = match[1];
    return phi0;
   }
   function eval_redshift_deriv(params, param){return params[2] ? 0. : 0.;}
   function eval$0(env, params, expr){
    switch(expr[0]){
      case 0:
       var n = expr[1]; return n;
      case 1:
       var name = expr[1], match = lookup(name, env);
       if(match){var v = match[1]; return v;}
       var _g_ = caml_call2(Stdlib_Printf[4], _b_, name);
       return caml_call1(Stdlib[2], _g_);
      case 2:
       var
        arg = expr[2],
        name$0 = expr[1],
        arg_val = eval$0(env, params, arg);
       if(name$0 === "b") return eval_shape(params, arg_val);
       if(name$0 === "b'") return eval_shape_deriv(params, arg_val);
       if(name$0 === "cos") return Math.cos(arg_val);
       if(name$0 === "exp") return Math.exp(arg_val);
       if(name$0 === "ln") return Math.log(arg_val);
       if(name$0 === "sin") return Math.sin(arg_val);
       if(name$0 === "sqrt") return Math.sqrt(arg_val);
       if(name$0 === "\xce\xa6") return eval_redshift(params, arg_val);
       if(name$0 === "\xce\xa6'") return eval_redshift_deriv(params, arg_val);
       var _h_ = caml_call2(Stdlib_Printf[4], _c_, name$0);
       return caml_call1(Stdlib[2], _h_);
      case 3:
       var e = expr[1]; return - eval$0(env, params, e);
      case 4:
       var b = expr[2], a = expr[1], _i_ = eval$0(env, params, b);
       return eval$0(env, params, a) + _i_;
      case 5:
       var b$0 = expr[2], a$0 = expr[1], _j_ = eval$0(env, params, b$0);
       return eval$0(env, params, a$0) - _j_;
      case 6:
       var b$1 = expr[2], a$1 = expr[1], _k_ = eval$0(env, params, b$1);
       return eval$0(env, params, a$1) * _k_;
      case 7:
       var b$2 = expr[2], a$2 = expr[1], denom = eval$0(env, params, b$2);
       return Math.abs(denom) < 1e-15
               ? Stdlib[24]
               : eval$0(env, params, a$2) / denom;
      case 8:
       var b$3 = expr[2], a$3 = expr[1], _l_ = eval$0(env, params, b$3);
       return Math.pow(eval$0(env, params, a$3), _l_);
      case 9:
       var e$0 = expr[1]; return Math.exp(eval$0(env, params, e$0));
      case 10:
       var e$1 = expr[1]; return Math.log(eval$0(env, params, e$1));
      case 11:
       var e$2 = expr[1]; return Math.sin(eval$0(env, params, e$2));
      case 12:
       var e$3 = expr[1]; return Math.cos(eval$0(env, params, e$3));
      case 13:
       var e$4 = expr[1]; return Math.sqrt(eval$0(env, params, e$4));
      case 14:
       var b$4 = expr[2], a$4 = expr[1]; return a$4 === b$4 ? 1. : 0.;
      default: return caml_call1(Stdlib[2], cst_Cannot_numerically_evaluat);
    }
   }
   function eval_at(b0, r, theta, expr){
    var env = wormhole_env(b0, r, theta, 0.), params = default_wormhole(b0);
    return eval$0(env, params, expr);
   }
   function eval_metric_component(metric, env, params, mu, nu){
    var expr = caml_call3(Dune_exe_Metric[3], metric, mu, nu);
    return eval$0(env, params, expr);
   }
   function eval_inverse_metric(metric, env, params, mu, nu){
    var expr = caml_call3(Dune_exe_Metric[4], metric, mu, nu);
    return eval$0(env, params, expr);
   }
   function eval_metric_matrix(metric, env, params){
    return caml_call2
            (Stdlib_Array[1],
             4,
             function(i){
              return caml_call2
                      (Stdlib_Array[1],
                       4,
                       function(j){
                        var
                         mu = caml_call1(Dune_exe_Metric[2], i),
                         nu = caml_call1(Dune_exe_Metric[2], j);
                        return eval_metric_component(metric, env, params, mu, nu);
                       });
             });
   }
   function eval_christoffel(cs, env, params, sigma, mu, nu){
    var expr = caml_call4(Dune_exe_Christoffel[4], cs, sigma, mu, nu);
    return eval$0(env, params, expr);
   }
   function eval_christoffel_array(cs, env, params){
    return caml_call2
            (Stdlib_Array[1],
             4,
             function(s){
              return caml_call2
                      (Stdlib_Array[1],
                       4,
                       function(m){
                        return caml_call2
                                (Stdlib_Array[1],
                                 4,
                                 function(n){
                                  var
                                   sigma = caml_call1(Dune_exe_Metric[2], s),
                                   mu = caml_call1(Dune_exe_Metric[2], m),
                                   nu = caml_call1(Dune_exe_Metric[2], n);
                                  return eval_christoffel(cs, env, params, sigma, mu, nu);
                                 });
                       });
             });
   }
   function gamma_num(params, r, theta){
    var
     b = eval_shape(params, r),
     b$0 = eval_shape_deriv(params, r),
     sin_th = Math.sin(theta),
     cos_th = Math.cos(theta),
     g_r_rr =
       Math.abs(r - b) < 1e-10
        ? Stdlib[24]
        : (b - r * b$0) / (2. * r * (r - b)),
     g_r_thth = - (r - b),
     g_r_phph = - (r - b) * sin_th * sin_th,
     g_th_rth = 1. / r,
     g_th_phph = - sin_th * cos_th,
     g_ph_rph = 1. / r,
     g_ph_thph = Math.abs(sin_th) < 1e-10 ? Stdlib[24] : cos_th / sin_th;
    return [0,
            g_r_rr,
            g_r_thth,
            g_r_phph,
            g_th_rth,
            g_th_phph,
            g_ph_rph,
            g_ph_thph];
   }
   function embedding_z(params, r){
    var match = params[1];
    if(0 === match[0]){
     var b0 = match[1];
     return r < b0 ? 0. : 2. * Math.sqrt(b0 * (r - b0));
    }
    var b0$0 = match[1];
    return r < b0$0 ? 0. : b0$0 * runtime.caml_acosh_float(r / b0$0);
   }
   function embedding_curve(params, r_max, n_points){
    var match = params[1];
    if(0 === match[0])
     var b = match[1], b0 = b;
    else
     var b$0 = match[1], b0 = b$0;
    var dr = (r_max - b0) / (n_points - 1 | 0);
    return caml_call2
            (Stdlib_Array[1],
             n_points,
             function(i){
              var r = b0 + i * dr, z = embedding_z(params, r);
              return [0, r, z];
             });
   }
   function proper_distance(params, r1, r2, n_steps){
    var
     dr = (r2 - r1) / n_steps,
     sum = [0, 0.],
     _e_ = n_steps - 1 | 0,
     _d_ = 0;
    if(_e_ >= 0){
     var i = _d_;
     for(;;){
      var
       r = r1 + (i + 0.5) * dr,
       b = eval_shape(params, r),
       integrand = 1. / Math.sqrt(1. - b / r);
      sum[1] = sum[1] + integrand * dr;
      var _f_ = i + 1 | 0;
      if(_e_ === i) break;
      i = _f_;
     }
    }
    return sum[1];
   }
   function light_travel_time(params, r1, r2, n_steps){return proper_distance(params, r1, r2, n_steps);
   }
   var
    Dune_exe_Numeric =
      [0,
       0,
       bind,
       lookup,
       wormhole_env,
       default_wormhole,
       ellis_wormhole,
       eval_shape,
       eval_shape_deriv,
       eval_redshift,
       eval_redshift_deriv,
       eval$0,
       eval_at,
       eval_metric_component,
       eval_inverse_metric,
       eval_metric_matrix,
       eval_christoffel,
       eval_christoffel_array,
       gamma_num,
       embedding_z,
       embedding_curve,
       proper_distance,
       light_travel_time];
   runtime.caml_register_global(43, Dune_exe_Numeric, "Dune__exe__Numeric");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLmpzX2JyaWRnZS5lb2Jqcy9qc29vL2R1bmVfX2V4ZV9fTnVtZXJpYy5jbW8uanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLmpzX2JyaWRnZS5lb2Jqcy9qc29vL2R1bmVfX2V4ZV9fTnVtZXJpYy5jbW8uanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJnbG9iYWxfZGF0YSIsImNzdCIsIlN0ZGxpYl9QcmludGYiLCJTdGRsaWIiLCJTdGRsaWJfQXJyYXkiLCJEdW5lX2V4ZV9NZXRyaWMiLCJEdW5lX2V4ZV9DaHJpc3RvZmZlbCIsIlN0ZGxpYl9MaXN0IiwiY3N0X3IiLCJjc3RfYiIsImNzdF9DYW5ub3RfbnVtZXJpY2FsbHlfZXZhbHVhdCIsImJpbmQiLCJuYW1lIiwidmFsdWUiLCJlbnYiLCJsb29rdXAiLCJ3b3JtaG9sZV9lbnYiLCJiMCIsInIiLCJ0aGV0YSIsInBoaSIsImRlZmF1bHRfd29ybWhvbGUiLCJlbGxpc193b3JtaG9sZSIsImV2YWxfc2hhcGUiLCJwYXJhbXMiLCJtYXRjaCIsImV2YWxfc2hhcGVfZGVyaXYiLCJldmFsX3JlZHNoaWZ0IiwicGhpMCIsImV2YWxfcmVkc2hpZnRfZGVyaXYiLCJwYXJhbSIsImV2YWwiLCJleHByIiwibiIsInYiLCJhcmciLCJhcmdfdmFsIiwiZSIsImIiLCJhIiwiZGVub20iLCJldmFsX2F0IiwiZXZhbF9tZXRyaWNfY29tcG9uZW50IiwibWV0cmljIiwibXUiLCJudSIsImV2YWxfaW52ZXJzZV9tZXRyaWMiLCJldmFsX21ldHJpY19tYXRyaXgiLCJpIiwiaiIsImV2YWxfY2hyaXN0b2ZmZWwiLCJjcyIsInNpZ21hIiwiZXZhbF9jaHJpc3RvZmZlbF9hcnJheSIsInMiLCJtIiwiZ2FtbWFfbnVtIiwic2luX3RoIiwiY29zX3RoIiwiZ19yX3JyIiwiZ19yX3RodGgiLCJnX3JfcGhwaCIsImdfdGhfcnRoIiwiZ190aF9waHBoIiwiZ19waF9ycGgiLCJnX3BoX3RocGgiLCJlbWJlZGRpbmdfeiIsImVtYmVkZGluZ19jdXJ2ZSIsInJfbWF4Iiwibl9wb2ludHMiLCJkciIsInoiLCJwcm9wZXJfZGlzdGFuY2UiLCJyMSIsInIyIiwibl9zdGVwcyIsInN1bSIsImludGVncmFuZCIsImxpZ2h0X3RyYXZlbF90aW1lIiwiRHVuZV9leGVfTnVtZXJpYyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9udW1lcmljLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxZQUFBQyxLQUFBQyxN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QUFDLFdBR0E7QUFBQSxLQUFBQyxZQUdDO0FBQUEsS0FBQUMsV0FHRDtBQUFBLEtBQUFDLFlBR0k7QUFBQSxJQUduQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBc0U7QUFBQSxZQUFBQyxZQUFBMUMsUUFBQU47QUFBQUEsUUFBQU8sUUFTdEU7QUFBQTtBQUFBLFNBQUFSLEtBQUE7QUFBQSxLQUVJLDBCQUNZLHdCQUdjO0FBQUE7QUFBQSxRQUFBQSxPQU45QjtBQUFBLElBS0ksOEJBQ1csa0NBQWU7QUFBQTtBQUFBLFlBQUFrRCxnQkFBQTNDLFFBQUE0QyxPQUFBQztBQUFBQSxRQUFBNUMsUUFJOUI7QUFBQTtBQUFBLFNBQUFhLElBQUEsVUFBQXJCLEtBQWdEO0FBQUE7QUFBQSxTQUFBcUIsTUFBaEQsVUFBQXJCLEtBQWdFO0FBQUEsUUFBQXFELEtBQ3ZEO0FBQUEsSUFDVDtBQUFBO0FBQUE7QUFBQSxzQkFBQXRCO0FBQUFBLGtCQUFBOUIsSUFDVSxhQUFBcUQsSUFDQTtBQUFBLGNBQ1I7QUFBQSxhQUFNLEVBQ1A7QUFBQTtBQUFBLFlBQUFDLGdCQUFBaEQsUUFBQWlELElBQUFDLElBQUFDO0FBQUFBO0FBQUFBLEtBQUFMLEtBUVE7QUFBQSxLQUFBTSxNQUNUO0FBQUEsV0FDQTtBQUFBO0FBQUE7QUFBQSxTQUFBNUIsSUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBOUIsSUFDVTtBQUFBLE9BQUFvQixJQUNBO0FBQUEsT0FBQXVDLFlBQ1EsS0FBTztBQUFBLE1BQ087QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFFaEM7QUFBQSxHQUFJO0FBQUEsWUFBQUMsa0JBQUF0RCxRQUFBaUQsSUFBQUMsSUFBQUMsU0FRSiwrQ0FBb0M7QUFBQTtBQUFBO0FBQUEsSUFBQUk7QUFBQUEsTUQ5UHRDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBudW1lcmljLm1sIC0gTnVtZXJpY2FsIGV2YWx1YXRpb24gb2Ygc3ltYm9saWMgZXhwcmVzc2lvbnMgKilcblxub3BlbiBFeHByXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgRU5WSVJPTk1FTlQ6IE1hcHMgdmFyaWFibGUgbmFtZXMgdG8gdmFsdWVzXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxudHlwZSBlbnYgPSAoc3RyaW5nICogZmxvYXQpIGxpc3RcblxubGV0IGVtcHR5X2VudiA6IGVudiA9IFtdXG5cbmxldCBiaW5kIG5hbWUgdmFsdWUgKGVudiA6IGVudikgOiBlbnYgPSAobmFtZSwgdmFsdWUpIDo6IGVudlxuXG5sZXQgbG9va3VwIG5hbWUgKGVudiA6IGVudikgPVxuICB0cnkgU29tZSAoTGlzdC5hc3NvYyBuYW1lIGVudilcbiAgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuXG4oKiBTdGFuZGFyZCB3b3JtaG9sZSBlbnZpcm9ubWVudCAqKVxubGV0IHdvcm1ob2xlX2VudiB+YjAgfnIgfnRoZXRhIH5waGkgPVxuICBbKFwiYuKCgFwiLCBiMCk7IChcInJcIiwgcik7IChcIs64XCIsIHRoZXRhKTsgKFwiz4ZcIiwgcGhpKTsgKFwidFwiLCAwLjApXVxuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIEZVTkNUSU9OIEVWQUxVQVRJT05cbiAgIFxuICAgRm9yIGIociksIM6mKHIpIGV0Yywgd2UgbmVlZCBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbnNcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG50eXBlIHNoYXBlX2ZuID0gXG4gIHwgQ29uc3RhbnRCIG9mIGZsb2F0ICAgICAgKCogYihyKSA9IGLigoAgKilcbiAgfCBFbGxpc0Igb2YgZmxvYXQgICAgICAgICAoKiBiKHIpID0gYuKCgMKyL3IgKilcblxudHlwZSByZWRzaGlmdF9mbiA9XG4gIHwgWmVyb1BoaSAgICAgICAgICAgICAgICAgKCogzqYocikgPSAwICopXG4gIHwgQ29uc3RhbnRQaGkgb2YgZmxvYXQgICAgKCogzqYocikgPSDOpuKCgCAqKVxuXG50eXBlIHdvcm1ob2xlX3BhcmFtcyA9IHtcbiAgc2hhcGUgOiBzaGFwZV9mbjtcbiAgcmVkc2hpZnQgOiByZWRzaGlmdF9mbjtcbn1cblxubGV0IGRlZmF1bHRfd29ybWhvbGUgYjAgPSB7XG4gIHNoYXBlID0gQ29uc3RhbnRCIGIwO1xuICByZWRzaGlmdCA9IFplcm9QaGk7XG59XG5cbmxldCBlbGxpc193b3JtaG9sZSBiMCA9IHtcbiAgc2hhcGUgPSBFbGxpc0IgYjA7XG4gIHJlZHNoaWZ0ID0gWmVyb1BoaTtcbn1cblxuKCogRXZhbHVhdGUgc2hhcGUgZnVuY3Rpb24gYW5kIGRlcml2YXRpdmVzICopXG5sZXQgZXZhbF9zaGFwZSBwYXJhbXMgciA9XG4gIG1hdGNoIHBhcmFtcy5zaGFwZSB3aXRoXG4gIHwgQ29uc3RhbnRCIGIwIC0+IGIwXG4gIHwgRWxsaXNCIGIwIC0+IGIwICouIGIwIC8uIHJcblxubGV0IGV2YWxfc2hhcGVfZGVyaXYgcGFyYW1zIHIgPVxuICBtYXRjaCBwYXJhbXMuc2hhcGUgd2l0aFxuICB8IENvbnN0YW50QiBfIC0+IDAuMFxuICB8IEVsbGlzQiBiMCAtPiAtLiBiMCAqLiBiMCAvLiAociAqLiByKVxuXG4oKiBFdmFsdWF0ZSByZWRzaGlmdCBmdW5jdGlvbiBhbmQgZGVyaXZhdGl2ZXMgKilcbmxldCBldmFsX3JlZHNoaWZ0IHBhcmFtcyBfciA9XG4gIG1hdGNoIHBhcmFtcy5yZWRzaGlmdCB3aXRoXG4gIHwgWmVyb1BoaSAtPiAwLjBcbiAgfCBDb25zdGFudFBoaSBwaGkwIC0+IHBoaTBcblxubGV0IGV2YWxfcmVkc2hpZnRfZGVyaXYgcGFyYW1zIF8gPVxuICBtYXRjaCBwYXJhbXMucmVkc2hpZnQgd2l0aFxuICB8IFplcm9QaGkgLT4gMC4wXG4gIHwgQ29uc3RhbnRQaGkgXyAtPiAwLjBcblxuKCogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICBFWFBSRVNTSU9OIEVWQUxVQVRJT05cbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG5sZXQgcmVjIGV2YWwgKGVudiA6IGVudikgKHBhcmFtcyA6IHdvcm1ob2xlX3BhcmFtcykgZXhwciA6IGZsb2F0ID1cbiAgbWF0Y2ggZXhwciB3aXRoXG4gIHwgTnVtIG4gLT4gblxuICB8IFZhciBuYW1lIC0+XG4gICAgICAobWF0Y2ggbG9va3VwIG5hbWUgZW52IHdpdGhcbiAgICAgICB8IFNvbWUgdiAtPiB2XG4gICAgICAgfCBOb25lIC0+IGZhaWx3aXRoIChQcmludGYuc3ByaW50ZiBcIlVuYm91bmQgdmFyaWFibGU6ICVzXCIgbmFtZSkpXG4gIFxuICB8IEZ1bmMgKG5hbWUsIGFyZykgLT5cbiAgICAgIGxldCBhcmdfdmFsID0gZXZhbCBlbnYgcGFyYW1zIGFyZyBpblxuICAgICAgKG1hdGNoIG5hbWUgd2l0aFxuICAgICAgIHwgXCJiXCIgLT4gZXZhbF9zaGFwZSBwYXJhbXMgYXJnX3ZhbFxuICAgICAgIHwgXCJiJ1wiIC0+IGV2YWxfc2hhcGVfZGVyaXYgcGFyYW1zIGFyZ192YWxcbiAgICAgICB8IFwizqZcIiAtPiBldmFsX3JlZHNoaWZ0IHBhcmFtcyBhcmdfdmFsXG4gICAgICAgfCBcIs6mJ1wiIC0+IGV2YWxfcmVkc2hpZnRfZGVyaXYgcGFyYW1zIGFyZ192YWxcbiAgICAgICB8IFwic2luXCIgLT4gc2luIGFyZ192YWxcbiAgICAgICB8IFwiY29zXCIgLT4gY29zIGFyZ192YWxcbiAgICAgICB8IFwiZXhwXCIgLT4gZXhwIGFyZ192YWxcbiAgICAgICB8IFwibG5cIiAtPiBsb2cgYXJnX3ZhbFxuICAgICAgIHwgXCJzcXJ0XCIgLT4gc3FydCBhcmdfdmFsXG4gICAgICAgfCBfIC0+IGZhaWx3aXRoIChQcmludGYuc3ByaW50ZiBcIlVua25vd24gZnVuY3Rpb246ICVzXCIgbmFtZSkpXG4gIFxuICB8IE5lZyBlIC0+IC0uIChldmFsIGVudiBwYXJhbXMgZSlcbiAgfCBBZGQgKGEsIGIpIC0+IGV2YWwgZW52IHBhcmFtcyBhICsuIGV2YWwgZW52IHBhcmFtcyBiXG4gIHwgU3ViIChhLCBiKSAtPiBldmFsIGVudiBwYXJhbXMgYSAtLiBldmFsIGVudiBwYXJhbXMgYlxuICB8IE11bCAoYSwgYikgLT4gZXZhbCBlbnYgcGFyYW1zIGEgKi4gZXZhbCBlbnYgcGFyYW1zIGJcbiAgfCBEaXYgKGEsIGIpIC0+IFxuICAgICAgbGV0IGRlbm9tID0gZXZhbCBlbnYgcGFyYW1zIGIgaW5cbiAgICAgIGlmIGFic19mbG9hdCBkZW5vbSA8IDFlLTE1IHRoZW4gbmFuXG4gICAgICBlbHNlIGV2YWwgZW52IHBhcmFtcyBhIC8uIGRlbm9tXG4gIHwgUG93IChhLCBiKSAtPiAoZXZhbCBlbnYgcGFyYW1zIGEpICoqIChldmFsIGVudiBwYXJhbXMgYilcbiAgfCBFeHAgZSAtPiBleHAgKGV2YWwgZW52IHBhcmFtcyBlKVxuICB8IExvZyBlIC0+IGxvZyAoZXZhbCBlbnYgcGFyYW1zIGUpXG4gIHwgU2luIGUgLT4gc2luIChldmFsIGVudiBwYXJhbXMgZSlcbiAgfCBDb3MgZSAtPiBjb3MgKGV2YWwgZW52IHBhcmFtcyBlKVxuICB8IFNxcnQgZSAtPiBzcXJ0IChldmFsIGVudiBwYXJhbXMgZSlcbiAgfCBEZWx0YSAoYSwgYikgLT4gaWYgYSA9IGIgdGhlbiAxLjAgZWxzZSAwLjBcbiAgfCBQYXJ0aWFsIF8gLT4gZmFpbHdpdGggXCJDYW5ub3QgbnVtZXJpY2FsbHkgZXZhbHVhdGUgdW5ldmFsdWF0ZWQgUGFydGlhbFwiXG5cbigqIENvbnZlbmllbmNlOiBldmFsdWF0ZSB3aXRoIHN0YW5kYXJkIHdvcm1ob2xlIHBhcmFtcyAqKVxubGV0IGV2YWxfYXQgfmIwIH5yIH50aGV0YSBleHByID1cbiAgbGV0IGVudiA9IHdvcm1ob2xlX2VudiB+YjAgfnIgfnRoZXRhIH5waGk6MC4wIGluXG4gIGxldCBwYXJhbXMgPSBkZWZhdWx0X3dvcm1ob2xlIGIwIGluXG4gIGV2YWwgZW52IHBhcmFtcyBleHByXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgTUVUUklDIE5VTUVSSUNBTCBFVkFMVUFUSU9OXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxub3BlbiBNZXRyaWNcblxubGV0IGV2YWxfbWV0cmljX2NvbXBvbmVudCBtZXRyaWMgZW52IHBhcmFtcyBtdSBudSA9XG4gIGxldCBleHByID0gZ2V0X2xvd2VyIG1ldHJpYyBtdSBudSBpblxuICBldmFsIGVudiBwYXJhbXMgZXhwclxuXG5sZXQgZXZhbF9pbnZlcnNlX21ldHJpYyBtZXRyaWMgZW52IHBhcmFtcyBtdSBudSA9XG4gIGxldCBleHByID0gZ2V0X3VwcGVyIG1ldHJpYyBtdSBudSBpblxuICBldmFsIGVudiBwYXJhbXMgZXhwclxuXG4oKiBHZXQgZnVsbCBtZXRyaWMgYXMgNHg0IGZsb2F0IGFycmF5ICopXG5sZXQgZXZhbF9tZXRyaWNfbWF0cml4IG1ldHJpYyBlbnYgcGFyYW1zID1cbiAgQXJyYXkuaW5pdCA0IChmdW4gaSAtPlxuICAgIEFycmF5LmluaXQgNCAoZnVuIGogLT5cbiAgICAgIGxldCBtdSA9IGlkeF90b19jb29yZCBpIGluXG4gICAgICBsZXQgbnUgPSBpZHhfdG9fY29vcmQgaiBpblxuICAgICAgZXZhbF9tZXRyaWNfY29tcG9uZW50IG1ldHJpYyBlbnYgcGFyYW1zIG11IG51XG4gICAgKVxuICApXG5cbigqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgQ0hSSVNUT0ZGRUwgTlVNRVJJQ0FMIEVWQUxVQVRJT05cbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG5vcGVuIENocmlzdG9mZmVsXG5cbmxldCBldmFsX2NocmlzdG9mZmVsIGNzIGVudiBwYXJhbXMgc2lnbWEgbXUgbnUgPVxuICBsZXQgZXhwciA9IGdldF9jaHJpc3RvZmZlbCBjcyBzaWdtYSBtdSBudSBpblxuICBldmFsIGVudiBwYXJhbXMgZXhwclxuXG4oKiBHZXQgYWxsIENocmlzdG9mZmVscyBhcyBmbG9hdCBhcnJheSAqKVxubGV0IGV2YWxfY2hyaXN0b2ZmZWxfYXJyYXkgY3MgZW52IHBhcmFtcyA9XG4gIEFycmF5LmluaXQgNCAoZnVuIHMgLT5cbiAgICBBcnJheS5pbml0IDQgKGZ1biBtIC0+XG4gICAgICBBcnJheS5pbml0IDQgKGZ1biBuIC0+XG4gICAgICAgIGxldCBzaWdtYSA9IGlkeF90b19jb29yZCBzIGluXG4gICAgICAgIGxldCBtdSA9IGlkeF90b19jb29yZCBtIGluXG4gICAgICAgIGxldCBudSA9IGlkeF90b19jb29yZCBuIGluXG4gICAgICAgIGV2YWxfY2hyaXN0b2ZmZWwgY3MgZW52IHBhcmFtcyBzaWdtYSBtdSBudVxuICAgICAgKVxuICAgIClcbiAgKVxuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIERJUkVDVCBOVU1FUklDQUwgQ0hSSVNUT0ZGRUxTIChmb3IgZWZmaWNpZW5jeSBpbiBnZW9kZXNpYyBpbnRlZ3JhdGlvbilcbiAgIFxuICAgVGhlc2UgY29tcHV0ZSDOkyBkaXJlY3RseSBmcm9tIHBhcmFtZXRlcnMgd2l0aG91dCBzeW1ib2xpYyBldmFsdWF0aW9uXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxubGV0IGdhbW1hX251bSBwYXJhbXMgfnIgfnRoZXRhID1cbiAgbGV0IGIgPSBldmFsX3NoYXBlIHBhcmFtcyByIGluXG4gIGxldCBiJyA9IGV2YWxfc2hhcGVfZGVyaXYgcGFyYW1zIHIgaW5cbiAgbGV0IHNpbl90aCA9IHNpbiB0aGV0YSBpblxuICBsZXQgY29zX3RoID0gY29zIHRoZXRhIGluXG4gIFxuICAoKiDOk15yX3JyID0gKGIgLSByKmInKSAvICgyKnIqKHItYikpICopXG4gIGxldCBnX3JfcnIgPSBcbiAgICBpZiBhYnNfZmxvYXQgKHIgLS4gYikgPCAxZS0xMCB0aGVuIG5hblxuICAgIGVsc2UgKGIgLS4gciAqLiBiJykgLy4gKDIuMCAqLiByICouIChyIC0uIGIpKSBpblxuICBcbiAgKCogzpNecl/OuM64ID0gLShyIC0gYikgKilcbiAgbGV0IGdfcl90aHRoID0gLS4gKHIgLS4gYikgaW5cbiAgXG4gICgqIM6TXnJfz4bPhiA9IC0ociAtIGIpICogc2luwrLOuCAqKVxuICBsZXQgZ19yX3BocGggPSAtLiAociAtLiBiKSAqLiBzaW5fdGggKi4gc2luX3RoIGluXG4gIFxuICAoKiDOk17OuF9yzrggPSAxL3IgKilcbiAgbGV0IGdfdGhfcnRoID0gMS4wIC8uIHIgaW5cbiAgXG4gICgqIM6TXs64X8+Gz4YgPSAtc2luzrggY29zzrggKilcbiAgbGV0IGdfdGhfcGhwaCA9IC0uIHNpbl90aCAqLiBjb3NfdGggaW5cbiAgXG4gICgqIM6TXs+GX3LPhiA9IDEvciAqKVxuICBsZXQgZ19waF9ycGggPSAxLjAgLy4gciBpblxuICBcbiAgKCogzpNez4ZfzrjPhiA9IGNvc864L3Npbs64ICopXG4gIGxldCBnX3BoX3RocGggPSBpZiBhYnNfZmxvYXQgc2luX3RoIDwgMWUtMTAgdGhlbiBuYW4gZWxzZSBjb3NfdGggLy4gc2luX3RoIGluXG4gIFxuICAoKiBSZXR1cm4gYXMgcmVjb3JkIGZvciBjbGFyaXR5ICopXG4gIChnX3JfcnIsIGdfcl90aHRoLCBnX3JfcGhwaCwgZ190aF9ydGgsIGdfdGhfcGhwaCwgZ19waF9ycGgsIGdfcGhfdGhwaClcblxuKCogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICBFTUJFRERJTkcgRElBR1JBTVxuICAgXG4gICB6KHIpIGZvciB2aXN1YWxpemF0aW9uIGluIDNEXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxubGV0IGVtYmVkZGluZ196IHBhcmFtcyByID1cbiAgbWF0Y2ggcGFyYW1zLnNoYXBlIHdpdGhcbiAgfCBDb25zdGFudEIgYjAgLT5cbiAgICAgIGlmIHIgPCBiMCB0aGVuIDAuMFxuICAgICAgZWxzZSAyLjAgKi4gc3FydCAoYjAgKi4gKHIgLS4gYjApKVxuICB8IEVsbGlzQiBiMCAtPlxuICAgICAgaWYgciA8IGIwIHRoZW4gMC4wXG4gICAgICBlbHNlIGIwICouIGFjb3NoIChyIC8uIGIwKVxuXG4oKiBHZW5lcmF0ZSBlbWJlZGRpbmcgY3VydmUgZGF0YSAqKVxubGV0IGVtYmVkZGluZ19jdXJ2ZSBwYXJhbXMgcl9tYXggbl9wb2ludHMgPVxuICBsZXQgYjAgPSBtYXRjaCBwYXJhbXMuc2hhcGUgd2l0aCBDb25zdGFudEIgYiAtPiBiIHwgRWxsaXNCIGIgLT4gYiBpblxuICBsZXQgZHIgPSAocl9tYXggLS4gYjApIC8uIGZsb2F0X29mX2ludCAobl9wb2ludHMgLSAxKSBpblxuICBBcnJheS5pbml0IG5fcG9pbnRzIChmdW4gaSAtPlxuICAgIGxldCByID0gYjAgKy4gZmxvYXRfb2ZfaW50IGkgKi4gZHIgaW5cbiAgICBsZXQgeiA9IGVtYmVkZGluZ196IHBhcmFtcyByIGluXG4gICAgKHIsIHopXG4gIClcblxuKCogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICBQUk9QRVIgRElTVEFOQ0UgKG51bWVyaWNhbCBpbnRlZ3JhdGlvbilcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqKVxuXG5sZXQgcHJvcGVyX2Rpc3RhbmNlIHBhcmFtcyByMSByMiBuX3N0ZXBzID1cbiAgKCog4oSTID0g4oirIGRyIC8g4oiaKDEgLSBiKHIpL3IpICopXG4gIGxldCBkciA9IChyMiAtLiByMSkgLy4gZmxvYXRfb2ZfaW50IG5fc3RlcHMgaW5cbiAgbGV0IHN1bSA9IHJlZiAwLjAgaW5cbiAgZm9yIGkgPSAwIHRvIG5fc3RlcHMgLSAxIGRvXG4gICAgbGV0IHIgPSByMSArLiAoZmxvYXRfb2ZfaW50IGkgKy4gMC41KSAqLiBkciBpblxuICAgIGxldCBiID0gZXZhbF9zaGFwZSBwYXJhbXMgciBpblxuICAgIGxldCBpbnRlZ3JhbmQgPSAxLjAgLy4gc3FydCAoMS4wIC0uIGIgLy4gcikgaW5cbiAgICBzdW0gOj0gIXN1bSArLiBpbnRlZ3JhbmQgKi4gZHJcbiAgZG9uZTtcbiAgIXN1bVxuXG4oKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIExJR0hUIFRSQVZFTCBUSU1FXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKilcblxubGV0IGxpZ2h0X3RyYXZlbF90aW1lIHBhcmFtcyByMSByMiBuX3N0ZXBzID1cbiAgKCogzpR0ID0g4oirIGRyIC8gKGMgKiDiiJooMSAtIGIvcikpLCB3aXRoIGMgPSAxICopXG4gIHByb3Blcl9kaXN0YW5jZSBwYXJhbXMgcjEgcjIgbl9zdGVwcyAgKCogU2FtZSBpbnRlZ3JhbCBmb3IgzqYgPSAwICopXG4iXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
